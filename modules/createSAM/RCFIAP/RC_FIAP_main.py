## ############################################################### ##
## RC_FIAP (Reinforced Concrete Frame Inelastic Analysis Platform) ##
##                                                                 ##
## Developed by:                                                   ##
##       Victor F. Ceballos (vceballos@uninorte.edu.co)            ##
##       Carlos A. Arteta (carteta@uninorte.edu.co                 ##
## RC_FIAP_main.py : this is the main script that calls            ##
## GUIFrameNonLinearACI.py : graphical environment                 ##
## mplwidget.py : cript to help plot the plastic hinge projector   ##
## ############################################################### ##

# Modified by Dr. Stevan Gavrilovic @ SimCenter, UC Berkeley

import sys, os
import argparse, json

from math import pi, sqrt, ceil, floor
from scipy import interpolate

import openseespy.opensees as op
import numpy as np  # load the numpy module, calling it np

import pandas as pd
import os
from mpl_toolkits.axes_grid1 import make_axes_locatable

# Definition of units
m = 1.0  # define basic units -- output units
kN = 1.0  # define basic units -- output units
sec = 1.0  # define basic units -- output units
mm = m / 1000.0  # define engineering units
cm = m / 100.0
N = kN / 1000.0
MPa = N / mm**2
GPa = MPa * 1000
m2 = m**2  # m^2
m3 = m**3  # m^3
m4 = m**4  # m^4
inch = cm * 2.54
ft = 12.0 * inch
g = 9.81 * m / sec**2  # gravitational acceleration
kip = 4.448 * kN
ksi = kip / inch**2
psi = ksi / 1000.0
lbf = psi * inch**2  # pounds force
pcf = lbf / ft**3  # pounds per cubic foot
psf = lbf / ft**3  # pounds per square foot
in2 = inch**2  # inch^2
in4 = inch**4  # inch^4
GConc = 24.0 * kN / m**3  # Specific gravity of concrete
cbar = False
np.set_printoptions(precision=6)


class BeamElasticElement:
    def __init__(
        self,
        EleTag,
        Nod_ini,
        Nod_end,
        AEle,
        EcEle,
        IzEle,
        LEle,
        BEle,
        HEle,
        ElegTr,
        RZi,
        RZe,
    ):
        self.EleTag = EleTag
        self.Nod_ini = Nod_ini
        self.Nod_end = Nod_end
        self.AEle = AEle
        self.EcEle = EcEle
        self.IzEle = IzEle
        self.LEle = LEle
        self.BEle = BEle
        self.HEle = HEle
        self.ElegTr = ElegTr
        self.RZi = RZi
        self.RZe = RZe


class BeamDesing:
    def __init__(
        self,
        EleTag,
        b,
        h,
        Ast1,
        dt1,
        Mn_n1,
        Asb1,
        db1,
        Mn_p1,
        ns1,
        ss1,
        Ast2,
        dt2,
        Mn_n2,
        Asb2,
        db2,
        Mn_p2,
        ns2,
        ss2,
        Nod_ini,
        Nod_end,
        db_t1,
        db_b1,
        db_t2,
        db_b2,
    ):
        self.EleTag = EleTag
        self.b = b
        self.h = h
        self.Ast1 = Ast1
        self.dt1 = dt1
        self.Mn_n1 = Mn_n1
        self.Asb1 = Asb1
        self.db1 = db1
        self.Mn_p1 = Mn_p1
        self.ns1 = ns1
        self.ss1 = ss1
        self.Ast2 = Ast2
        self.dt2 = dt2
        self.Mn_n2 = Mn_n2
        self.Asb2 = Asb2
        self.db2 = db2
        self.Mn_p2 = Mn_p2
        self.ns2 = ns2
        self.ss2 = ss2
        self.Nod_ini = Nod_ini
        self.Nod_end = Nod_end
        self.db_t1 = db_t1
        self.db_b1 = db_b1
        self.db_t2 = db_t2
        self.db_b2 = db_b2


class ColDesing:
    def __init__(
        self,
        EleTag,
        b,
        h,
        nbH,
        nbB,
        db,
        As,
        Pu_v,
        Mu_v,
        fiPn,
        fiMn,
        Mn_i,
        d,
        dist,
        ro,
        Mu_i,
        sst,
        nsB,
        nsH,
        Nod_ini,
        Nod_end,
    ):
        self.EleTag = EleTag
        self.b = b
        self.h = h
        self.nbH = nbH
        self.nbB = nbB
        self.db = db
        self.As = As
        self.Pu_v = Pu_v
        self.Mu_v = Mu_v
        self.fiPn = fiPn
        self.fiMn = fiMn
        self.Mn_i = Mn_i
        self.d = d
        self.dist = dist
        self.ro = ro
        self.Mu_i = Mu_i
        self.sst = sst
        self.nsB = nsB
        self.nsH = nsH
        self.Nod_ini = Nod_ini
        self.Nod_end = Nod_end


class DuctilityCurve:
    def __init__(self, xi, xe, yi, ye, CD_i, CD_e):
        self.xi = xi
        self.xe = xe
        self.yi = yi
        self.ye = ye
        self.CD_i = CD_i
        self.CD_e = CD_e


class TclLogger:
    def __init__(self):
        self.list_of_lines = [
            '# This is an autogenerated .tcl file from SimCenter workflow'
        ]

    # Add a string line to the output file
    def add_line(self, line, addNewLine=True):
        if addNewLine == True:
            self.list_of_lines.append(line + '\n')
        else:
            self.list_of_lines.append(line)

    # Convenience function to create a line from an array of inputs to openseespy function
    def add_array(self, line, addNewLine=True):
        outLine = ''
        for item in line:
            outLine += str(item) + ' '

        #        # Remove the last space
        #        outLine = outLine.rstrip()
        #
        #        # Add the ; char to the end of the line
        #        outLine += ';'
        self.add_line(outLine, addNewLine)

    # Save the output file
    def save_as_file(self):
        # Get the current directory
        workingDirectory = os.getcwd()

        pathFile = os.path.join(workingDirectory, 'Model.tcl')

        if os.path.exists(pathFile):
            os.remove(pathFile)

        with open(pathFile, 'a+') as file_object:
            appendEOL = False
            # Move read cursor to the start of file.
            file_object.seek(0)

            # Check if file is not empty
            data = file_object.read(100)

            if len(data) > 0:
                appendEOL = True

            # Iterate over each string in the list
            for line in self.list_of_lines:
                # If file is not empty then append '\n' before first line for
                # other lines always append '\n' before appending line
                if appendEOL == True:
                    file_object.write('\n')
                else:
                    appendEOL = True
                # Append element at the end of file
                file_object.write(line)

        # print(self.list_of_lines)


def runBuildingDesign(BIM_file, EVENT_file, SAM_file, getRV):
    # Get the current directory
    workingDirectory = os.getcwd()

    rootSIM = {}

    # Try to open the BIM json
    with open(BIM_file, 'r', encoding='utf-8') as f:
        rootBIM = json.load(f)
    try:
        # rootSIM = rootBIM['StructuralInformation']
        rootSIM = rootBIM['Modeling']
        # KZ: append simulation attribute
        rootSIM['Simulation'] = rootBIM.get('Simulation', None)
    except:
        raise ValueError('RC_FIAP - structural information missing')

    # Get the random variables from the input file
    try:
        rootRV = rootBIM['randomVariables']
    except:
        raise ValueError('RC_FIAP - randomVariables section missing')

    RV_ARRAY = {}

    # Populate the RV array with name/value pairs.
    # If a random variable is used here, the RV array will contain its current value
    for rv in rootRV:
        # Try to get the name and value of the random variable
        rvName = rv['name']
        curVal = rv['value']

        # Check if the current value a realization of a RV, i.e., is not a RV label
        # If so, then set the current value as the mean
        if 'RV' in str(curVal):
            curVal = float(rv['mean'])

        RV_ARRAY[rvName] = curVal

    # *********************** Design Starts Here *************************
    # if getRV == "False":
    if getRV is False:
        print('Running seismic design in FIAP')

        # Create the tcl output logger
        outputLogger = TclLogger()

        outputLogger.add_line(
            '# Reinforced Concrete Frame Inelastic Analysis Platform (RCFIAP)', False
        )
        outputLogger.add_line(
            '# Developed by Victor Ceballos & Carlos Arteta', False
        )
        outputLogger.add_line(
            '# Modified by Stevan Gavrilovic - NHERI SimCenter for use in EE-UQ'
        )

        # Create a class object
        RCDes = RCFIAP()

        print('Starting seismic design')

        # Run the building design
        RCDes.Design(rootSIM)

        print('Creating nonlinear model')

        # Run a pushover analysis - for testing to compare with original code
        doPushover = False

        # Create the nonlinear model
        RCDes.CreateNLM(rootSIM, outputLogger, doPushover)

        # Save the output file from the logger
        outputLogger.save_as_file()

        if doPushover == True:
            print('Running pushover analysis')
            RCDes.Pushover(rootSIM)

    # Now create the SAM file for export
    root_SAM = {}

    root_SAM['mainScript'] = 'Model.tcl'
    root_SAM['type'] = 'OpenSeesInput'
    root_SAM['units'] = {
        'force': 'kN',
        'length': 'm',
        'temperature': 'C',
        'time': 'sec',
    }

    # Number of dimensions
    root_SAM['ndm'] = 2

    # Number of degrees of freedom at each node
    root_SAM['ndf'] = 3

    # The number of stories
    vecHeights = rootSIM['VecStoryHeights']
    vecHeights = vecHeights.split(',')
    vecHeights = np.array(vecHeights, dtype=float)

    numStories = len(vecHeights)
    root_SAM['numStory'] = numStories

    # The number of spans
    vecSpans = rootSIM['VecSpans']
    vecSpans = vecSpans.split(',')
    vecSpans = np.array(vecSpans, dtype=float)
    numSpans = len(vecSpans)

    # Get the node mapping
    # Consider a structure with 3 stories and 2 spans
    # Then the node numbering scheme is
    #   #9——————#10———————#11
    #   |        |        |
    #   |        |        |
    #   #6——————#7———————#8
    #   |        |        |
    #   |        |        |
    #   #3——————#4———————#5
    #   |        |        |
    #   |        |        |
    #   #0       #1      #2

    clineOffset = 0
    if numSpans > 1:
        clineOffset = int(numSpans / 2)

    node_map = []

    # Using nodes on column #1 to calculate story drift
    for i in range(0, numStories + 1):
        nodeTag = i * (numSpans + 1)

        # Create the node and add it to the node mapping array
        node_entry = {}
        node_entry['node'] = nodeTag
        node_entry['cline'] = 'response'
        node_entry['floor'] = '{}'.format(i)
        node_map.append(node_entry)

        ## KZ & AZ: Add centroid for roof drift
        node_entry_c = {}
        node_entry_c['node'] = nodeTag + clineOffset
        node_entry_c['cline'] = 'centroid'
        node_entry_c['floor'] = '{}'.format(i)
        node_map.append(node_entry_c)

    root_SAM['NodeMapping'] = node_map

    with open(SAM_file, 'w') as f:
        json.dump(root_SAM, f, indent=2)


# Main functionality
class RCFIAP:
    def Design(self, rootSIM):
        def __init__(rootSIM):
            self.rootSIM = rootSIM

        global \
            Loc_span, \
            Loc_heigth, \
            ListNodes, \
            Elements, \
            DataBeamDesing, \
            DataColDesing, \
            WDL, \
            WLL, \
            WDLS, \
            Wtotal, \
            cover

        # Function: Reads Beams design data from table that allows the user to modify the default design from TAB2 of GUI
        def data_beams_table(self):
            self.registros_beams = []

            for DB in DataBeamDesing:
                b = DB.b / cm
                h = DB.h / cm
                L_As_top = DB.Ast1 / cm**2
                L_As_bot = DB.Asb1 / cm**2
                R_As_top = DB.Ast2 / cm**2
                R_As_bot = DB.Asb2 / cm**2
                L_Leg_n = DB.ns1
                R_Leg_n = DB.ns2
                L_Sstirrup = DB.ss1 / cm
                R_Sstirrup = DB.ss2 / cm
                registro = RegistroBeams(
                    DB.EleTag,
                    b,
                    h,
                    L_As_top,
                    L_As_bot,
                    L_Leg_n,
                    L_Sstirrup,
                    R_As_top,
                    R_As_bot,
                    R_Leg_n,
                    R_Sstirrup,
                )
                self.registros_beams.append(registro)

        # Function: Reads Columns design data from table that allows the user to modify the default design from TAB2 of GUI.
        def data_columns_table(self):
            self.registros_cols = []

            for DC in DataColDesing:
                b = DC.b / cm
                h = DC.h / cm
                db = DC.db / mm
                nbH = DC.nbH
                nbB = DC.nbB
                nsH = DC.nsH
                nsB = DC.nsB
                sst = DC.sst / cm
                registro = RegistroColumns(
                    DC.EleTag, b, h, db, nbH, nbB, nsH, nsB, sst
                )
                self.registros_cols.append(registro)

        # Compression block parameters beta as function f'c
        def beta1(fc):
            if fc <= 28 * MPa:
                Beta1 = 0.85
            else:
                Beta1 = max([0.85 - 0.05 * (fc - 28.0) / 7.0, 0.65])
            return Beta1

        # Design load combinations
        def Combo_ACI(DL, LL, E):
            U1 = 1.2 * DL + 1.6 * LL
            U2 = 1.2 * DL + 1.0 * LL + 1.0 * E
            U3 = 1.2 * DL + 1.0 * LL - 1.0 * E
            U4 = 0.9 * DL + 1.0 * E
            U5 = 0.9 * DL - 1.0 * E
            return U1, U2, U3, U4, U5

        # Flexural beams design
        def AsBeam(Mu, EleTag):
            b, h = BBeam, HBeam
            Mu = abs(Mu)
            db_v = np.array([4, 5, 6, 7, 8, 10])
            for ndb in db_v:
                db = ndb / 8.0 * inch
                d = h - cover - dst - 0.5 * db
                if Mu == 0.0:
                    ro_req = ro_min_b
                else:
                    ro_req = (
                        0.85
                        * fcB
                        / fy
                        * (
                            1.0
                            - sqrt(1.0 - 2.0 * (Mu / 0.9 / b / d**2) / 0.85 / fcB)
                        )
                    )
                if ro_req < ro_min_b:
                    ro_req = ro_min_b
                As_req = ro_req * b * d
                Ab = pi * db**2 / 4.0
                nb = max(2.0, ceil(As_req / Ab))
                As_con = nb * Ab
                slb = (b - 2 * cover - 2 * dst - nb * db) / (
                    nb - 1.0
                )  # free clear bars
                if slb >= max(1.0 * inch, db):
                    break
                if ro_req > ro_max_b:
                    print(
                        'Steel percentage greater than the maximum in Beam '
                        + str(EleTag)
                    )
            if slb < min(1.0 * inch, db):
                print('Bar separation is not ok in Beam ' + str(EleTag))
            a = fy * As_con / 0.85 / fcB / b
            Mn = fy * As_con * (d - a / 2.0)
            return As_con, d, Mn, db

        # Shear beams design
        def AvBeam(Vu, db, d, EleTag):
            Vc = 0.17 * sqrt(fcB / 1000.0) * MPa * BBeam * d
            Vs = (Vu - 0.75 * Vc) / 0.75
            if Vs > 4.0 * Vc:
                print('reshape by shear in Beam ' + str(EleTag))
            se_1 = min(d / 4.0, 8.0 * db, 24.0 * dst, 300.0 * mm)
            nr_v = np.array([2, 3, 4])  # vector de numero de ramas
            if Vs <= 0.0:
                se = se_1
                nra = 2.0
            else:
                for nra in nr_v:
                    Ave = Ast * nra  # area transversal del estribo
                    se_2 = Ave * fy * d / Vs
                    se = min(se_1, se_2)
                    if se >= 60.0 * mm:
                        break
            se = floor(se / cm) * cm
            if se < 60.0 * mm:
                print('Stirrup spacing is less than 6 cm in beam ' + str(EleTag))
            return nra, se

        # Colmuns P-M design
        def AsColumn():
            verif = False
            while verif == False:
                for ndb in db_v:
                    db = ndb / 8.0 * inch
                    Ab = pi * db**2.0 / 4.0
                    dp = cover + dst + 0.5 * db
                    d = h - dp
                    for nbH in nbH_v:
                        for nbB in nbB_v:
                            nbT = 2.0 * (nbB + nbH - 2.0)  # numero total de barras
                            Ast = nbT * Ab
                            ro = Ast / b / h
                            As = np.hstack(
                                [nbB * Ab, np.ones(nbH - 2) * 2 * Ab, nbB * Ab]
                            )
                            dist = np.linspace(dp, h - dp, nbH)
                            if ro >= ro_min:
                                Pn_max = 0.80 * (
                                    0.85 * fcC * (b * h - Ast) + fy * Ast
                                )
                                Tn_max = -fy * Ast
                                c = np.linspace(1.1 * h / npts, 1.1 * h, npts)
                                a = Beta1C * c
                                Pconc = 0.85 * fcC * a * b
                                Mconc = Pconc * (h - a) / 2.0
                                et = ecu * (d - c) / c
                                fiv = np.copy(et)
                                fiv = np.where(fiv >= 0.005, 0.9, fiv)
                                fiv = np.where(fiv <= 0.002, 0.65, fiv)
                                fiv = np.where(
                                    (fiv > 0.002) & (fiv < 0.005),
                                    (0.65 + 0.25 * (fiv - 0.002) / 0.003),
                                    fiv,
                                )
                                c = c[:, np.newaxis]
                                es = ecu * (c - dist) / c
                                fs = Es * es
                                fs = np.where(fs > fy, fy, fs)
                                fs = np.where(fs < -fy, -fy, fs)
                                Pacer = np.sum(fs * As, axis=1)
                                Macer = np.sum(fs * As * (h / 2.0 - dist), axis=1)
                                Pn = np.hstack(
                                    [
                                        Tn_max,
                                        np.where(
                                            Pconc + Pacer > Pn_max,
                                            Pn_max,
                                            Pconc + Pacer,
                                        ),
                                        Pn_max,
                                    ]
                                )
                                Mn = np.hstack([0, Mconc + Macer, 0])
                                fiv = np.hstack([0.9, fiv, 0.65])
                                fiPn = fiv * Pn
                                fiMn = fiv * Mn
                                if np.all((Pu_v >= min(fiPn)) & (Pu_v <= max(fiPn))):
                                    Mu_i = np.interp(Pu_v, fiPn, fiMn)
                                    Mn_i = np.interp(Pu_v, Pn, Mn)
                                    if np.all(Mu_i >= Mu_v) == True:
                                        verif = True
                                        break
                        if verif == True:
                            break
                    if verif == True:
                        break
                if ndb == db_v[-1] and ro > ro_max:
                    print(
                        'column '
                        + str(EleTag)
                        + 'needs to be resized by reinforcement ratio'
                    )
                    break
            return nbH, nbB, db, As, fiPn, fiMn, Mn_i, d, dist, ro, Mu_i

        # Shear columns design
        def AvColumn():
            fiv = 0.75
            Ag = b * h
            se_1 = min(
                8.0 * db, b / 2.0, h / 2.0, 200.0 * mm
            )  # separacion minima c.18.4.3.3 ACI-19
            dp = cover + dst + db / 2
            d = h - dp
            neH = floor(nbH / 2) + 1
            neB = floor(nbB / 2) + 1

            Ash_H = neH * Ast
            Ash_B = neB * Ast

            Vc = (0.17 * sqrt(fcC * MPa) + Nu_min / 6 / Ag) * b * d
            Vs = (Vu - fiv * Vc) / fiv
            if Vs <= 1 / 3 * sqrt(fcC * MPa) * b * d:
                se_1 = se_1
            elif Vs >= 1 / 3 * sqrt(fcC * MPa) * b * d:
                se_1 = min(se_1, h / 4)

            if Vs > 0.66 * sqrt(fcC * MPa) * b * d:
                print('Resize the column' + str(EleTag) + ' by shear ')

            if Vs <= 0.0:
                se = se_1
            else:
                Ave = Ash_B  # area transversal del estribo
                se_2 = Ave * fy * d / Vs
                se = min([se_1, se_2])
            if se < 60.0 * mm:
                print(
                    'Minimum spacing of stirrups is not met in column ' + str(EleTag)
                )
            return se, neB, neH

        # Input geometric, materials and seismic design parameters from TAB1 of GUI

        # Lafg = float(self.ui.Lafg.text())
        Lafg = float(rootSIM['TribLengthGravity'])

        # Lafs = float(self.ui.Lafs.text())
        Lafs = float(rootSIM['TribLengthSeismic'])

        # DL = float(self.ui.DL.text())
        DL = float(rootSIM['DeadLoad'])

        # LL = float(self.ui.LL.text())
        LL = float(rootSIM['LiveLoad'])

        # HColi = float(self.ui.HColi.text())  # Column inside Depth
        HColi = float(rootSIM['IntColDepth'])

        # BColi = float(self.ui.BColi.text())  # Column inside Width
        BColi = float(rootSIM['IntColWidth'])

        # HCole = float(self.ui.HCole.text())  # Column outside Depth
        HCole = float(rootSIM['ExtColDepth'])

        # BCole = float(self.ui.BCole.text())  # Column outside Width
        BCole = float(rootSIM['ExtColWidth'])

        # HBeam = float(self.ui.HBeam.text())
        HBeam = float(rootSIM['BeamDepth'])

        # BBeam = float(self.ui.BBeam.text())
        BBeam = float(rootSIM['BeamWidth'])

        # IFC = float(self.ui.InertiaColumnsFactor.text())
        IFC = float(rootSIM['ColIg'])

        # IFB = float(self.ui.InertiaBeamsFactor.text())
        IFB = float(rootSIM['BeamIg'])

        # heigth_v = self.ui.heigth_v.text()
        heigth_v = rootSIM['VecStoryHeights']

        heigth_v = heigth_v.split(',')
        heigth_v = np.array(heigth_v, dtype=float)

        # span_v = self.ui.span_v.text()
        span_v = rootSIM['VecSpans']

        span_v = span_v.split(',')
        span_v = np.array(span_v, dtype=float)

        # fy = float(self.ui.fy.text()) * MPa
        fy = float(rootSIM['FySteel']) * MPa

        # fcB = float(self.ui.fcB.text()) * MPa
        fcB = float(rootSIM['BeamFpc']) * MPa

        # fcC = float(self.ui.fcC.text()) * MPa
        fcC = float(rootSIM['ColFpc']) * MPa

        # R = float(self.ui.R.text())
        R = float(rootSIM['RParam'])

        # Cd = float(self.ui.Cd.text())
        Cd = float(rootSIM['CdParam'])

        # Omo = float(self.ui.Omo.text())
        Omo = float(rootSIM['OmegaParam'])

        # Sds = float(self.ui.Sds.text())
        Sds = float(rootSIM['SDSParam'])

        # Sd1 = float(self.ui.Sd1.text())
        Sd1 = float(rootSIM['SD1Param'])

        # Tl = float(self.ui.Tl.text())
        Tl = float(rootSIM['TLParam'])

        WDL = Lafg * DL
        WDLS = Lafs * DL
        WLL = Lafg * LL

        #        print("heigth_v: ")
        #        print(heigth_v)
        #        print("span_v: ")
        #        print(span_v)
        #        print("Lafg: "+str(Lafg))
        #        print("Lafs: "+str(Lafs))
        #        print("DL: "+str(DL))
        #        print("LL: "+str(LL))
        #        print("HColi: "+str(HColi))
        #        print("BColi: "+str(BColi))
        #        print("HCole: "+str(HCole))
        #        print("BCole: "+str(BCole))
        #        print("HBeam: "+str(HBeam))
        #        print("BBeam: "+str(BBeam))
        #        print("IFC: "+str(IFC))
        #        print("IFB: "+str(IFB))
        print('********************fy: ', fy)
        #        print("fcB: "+str(fcB))
        #        print("fcC: "+str(fcC))
        #        print("R: "+str(R))
        #        print("Cd: "+str(Cd))
        #        print("Omo: "+str(Omo))
        #        print("Sds: "+str(Sds))
        #        print("Sd1: "+str(Sd1))
        #        print("Tl: "+str(Tl))

        # plt.close('all')
        op.wipe()
        op.model('Basic', '-ndm', 2, '-ndf', 3)

        # Nodes Creations
        Loc_span = np.append(0, np.cumsum(span_v))
        Loc_heigth = np.append(0, np.cumsum(heigth_v))
        n_col_axes = len(Loc_span)
        xn_v, yn_v = np.meshgrid(Loc_span, Loc_heigth)
        xn_vf = np.ravel(xn_v)
        yn_vf = np.ravel(yn_v)
        num_nodes = len(Loc_span) * len(Loc_heigth)
        ListNodes = np.empty([num_nodes, 3])
        nodeTag = 0
        for xn, yn in zip(xn_vf, yn_vf):
            ListNodes[nodeTag, :] = [nodeTag, xn, yn]
            op.node(nodeTag, xn, yn)
            if yn == 0.0:
                op.fix(nodeTag, 1, 1, 1)
            nodeTag += 1
        for node in ListNodes:
            if node[2] > 0.0 and node[1] == 0.0:
                MasterNode = node[0]
            if node[2] > 0.0 and node[1] != 0.0:
                op.equalDOF(int(MasterNode), int(node[0]), 1)

        ListNodesDrift = ListNodes[np.where(ListNodes[:, 1] == 0.0)]
        MassType = '-lMass'  # -lMass, -cMass

        # Columns creation for elastic analysis
        op.geomTransf('Linear', 1, '-jntOffset', 0, 0, 0, -HBeam / 2)
        op.geomTransf('Linear', 2, '-jntOffset', 0, HBeam / 2, 0, -HBeam / 2)
        AColi = BColi * HColi  # cross-sectional area
        ACole = BCole * HCole  # cross-sectional area
        EcC = 4700 * sqrt(fcC * MPa)
        IzColi = 1.0 / 12.0 * BColi * HColi**3  # Column moment of inertia
        IzCole = 1.0 / 12.0 * BCole * HCole**3  # Column moment of inertia
        EleTag = 1
        Elements = []
        for Nod_ini in range(num_nodes):
            if ListNodes[Nod_ini, 2] != Loc_heigth[-1]:
                Nod_end = Nod_ini + n_col_axes
                if ListNodes[Nod_ini, 2] == 0.0:
                    gTr = 1
                    RZi = 0
                    RZe = HBeam / 2
                    LCol = ListNodes[Nod_end, 2] - ListNodes[Nod_ini, 2] - RZi - RZe
                else:
                    gTr = 2
                    RZi = HBeam / 2
                    RZe = HBeam / 2
                    LCol = ListNodes[Nod_end, 2] - ListNodes[Nod_ini, 2] - RZi - RZe
                if (
                    ListNodes[Nod_ini, 1] == 0.0
                    or ListNodes[Nod_ini, 1] == Loc_span[-1]
                ):
                    BCol, HCol = BCole, HCole
                    ACol = ACole
                    IzCol = IFC * IzCole
                else:
                    BCol, HCol = BColi, HColi
                    ACol = AColi
                    IzCol = IFC * IzColi
                MassDens = ACol * GConc / g
                Elements.append(
                    BeamElasticElement(
                        EleTag,
                        Nod_ini,
                        Nod_end,
                        ACol,
                        EcC,
                        IzCol,
                        LCol,
                        BCol,
                        HCol,
                        gTr,
                        RZi,
                        RZe,
                    )
                )
                op.element(
                    'elasticBeamColumn',
                    EleTag,
                    Nod_ini,
                    Nod_end,
                    ACol,
                    EcC,
                    IzCol,
                    gTr,
                    '-mass',
                    MassDens,
                    MassType,
                )
                EleTag += 1
        num_cols = EleTag

        # Beams creation for elastic analysis
        op.geomTransf('Linear', 3, '-jntOffset', HColi / 2.0, 0, -HColi / 2.0, 0)
        op.geomTransf('Linear', 4, '-jntOffset', HCole / 2.0, 0, -HColi / 2.0, 0)
        op.geomTransf('Linear', 5, '-jntOffset', HColi / 2.0, 0, -HCole / 2.0, 0)
        ABeam = BBeam * HBeam
        EcB = 4700 * sqrt(fcB * MPa)
        IzBeam = IFB * BBeam * HBeam**3 / 12
        MassDens = ABeam * GConc / g + WDLS / g
        for Nod_ini in range(num_nodes):
            if (
                ListNodes[Nod_ini, 1] != Loc_span[-1]
                and ListNodes[Nod_ini, 2] != 0.0
            ):
                Nod_end = Nod_ini + 1
                if ListNodes[Nod_ini, 1] == 0.0:
                    gTr = 4
                    RZi = HCole / 2.0
                    RZe = HColi / 2.0
                    LBeam = ListNodes[Nod_end, 1] - ListNodes[Nod_ini, 1] - RZi - RZe
                elif ListNodes[Nod_ini, 1] == Loc_span[-2]:
                    gTr = 5
                    RZi = HColi / 2.0
                    RZe = HCole / 2.0
                    LBeam = ListNodes[Nod_end, 1] - ListNodes[Nod_ini, 1] - RZi - RZe
                else:
                    gTr = 3
                    RZi = HColi / 2.0
                    RZe = HColi / 2.0
                    LBeam = ListNodes[Nod_end, 1] - ListNodes[Nod_ini, 1] - RZi - RZe
                Elements.append(
                    BeamElasticElement(
                        EleTag,
                        Nod_ini,
                        Nod_end,
                        ABeam,
                        EcB,
                        IzBeam,
                        LBeam,
                        BBeam,
                        HBeam,
                        gTr,
                        RZi,
                        RZe,
                    )
                )
                op.element(
                    'elasticBeamColumn',
                    EleTag,
                    Nod_ini,
                    Nod_end,
                    ABeam,
                    EcB,
                    IzBeam,
                    gTr,
                    '-mass',
                    MassDens,
                    MassType,
                )
                EleTag += 1
        num_elems = EleTag
        num_beams = num_elems - num_cols

        # Create a Plain load pattern for gravity loading with a Linear TimeSeries
        Pvig = ABeam * GConc
        PColi = AColi * GConc
        PCole = ACole * GConc
        op.timeSeries('Linear', 1)
        op.pattern('Plain', 1, 1)
        for Element in Elements:
            if ListNodes[Element.Nod_ini, 1] == ListNodes[Element.Nod_end, 1]:
                if (
                    ListNodes[Element.Nod_ini, 1] == 0.0
                    or ListNodes[Element.Nod_ini, 1] == Loc_span[-1]
                ):
                    PCol = PCole
                else:
                    PCol = PColi
                op.eleLoad('-ele', Element.EleTag, '-type', '-beamUniform', 0, -PCol)
            if ListNodes[Element.Nod_ini, 2] == ListNodes[Element.Nod_end, 2]:
                op.eleLoad(
                    '-ele', Element.EleTag, '-type', '-beamUniform', -Pvig - WDL
                )

        op.system('UmfPack')
        op.numberer('Plain')
        op.constraints('Plain')
        op.integrator('LoadControl', 1.0)
        op.algorithm('Linear')
        op.analysis('Static')
        op.analyze(1)
        ElemnsForceD = []
        for Element in Elements:
            Forces = op.eleForce(Element.EleTag)
            Forces.insert(0, Element.EleTag)
            ElemnsForceD.append(Forces)
        ElemnsForceD = np.array(ElemnsForceD)
        Wtotal = np.sum(ElemnsForceD[: len(Loc_span), 2]) * Lafs / Lafg

        op.loadConst('-time', 0.0)
        op.timeSeries('Linear', 2)
        op.pattern('Plain', 2, 1)
        for Element in Elements:
            if ListNodes[Element.Nod_ini, 2] == ListNodes[Element.Nod_end, 2]:
                op.eleLoad('-ele', Element.EleTag, '-type', '-beamUniform', -WLL)
        op.analyze(1)

        # Frame Geometry plot
        #        self.ui.DataFrame.canvas.axes.clear()
        #        self.ui.DataFrame.canvas.axes.plot(ListNodes[:, 1], ListNodes[:, 2], 'ks')
        #
        #        self.ui.DataFrame.canvas.axes.axis('off')
        #        for Ele in Elements:
        #            xi = ListNodes[Ele.Nod_ini, 1]
        #            yi = ListNodes[Ele.Nod_ini, 2]
        #            xe = ListNodes[Ele.Nod_end, 1]
        #            ye = ListNodes[Ele.Nod_end, 2]
        #            self.ui.DataFrame.canvas.axes.plot([xi, xe], [yi, ye], 'k-', alpha=.3)
        #            if xi == xe:
        #                self.ui.DataFrame.canvas.axes.text(xi, (ye + yi) / 2, r'C{}'.format(Ele.EleTag), style='italic',
        #                                                   fontsize=8,
        #                                                   rotation='vertical', verticalalignment='center')
        #            if yi == ye:
        #                self.ui.DataFrame.canvas.axes.text((xe + xi) / 2, yi, r'B{}'.format(Ele.EleTag), style='italic',
        #                                                   fontsize=8,
        #                                                   horizontalalignment='center')
        #        self.ui.DataFrame.canvas.axes.axis('equal')
        #        self.ui.DataFrame.canvas.draw()
        #        self.ui.DataFrame.canvas.show()

        ElemnsForceDL = []
        for Element in Elements:
            Forces = op.eleForce(Element.EleTag)
            Forces.insert(0, Element.EleTag)
            ElemnsForceDL.append(Forces)
        ElemnsForceDL = np.array(ElemnsForceDL)

        # Create a Plain load pattern for seismic loading with a Linear TimeSeries (LLEF)
        op.loadConst('-time', 0.0)
        Htotal = Loc_heigth[-1]
        Ct = 0.0466
        x = 0.9
        Ta = Ct * Htotal**x
        print('Ta =', Ta)
        Ie = 1.0
        Ts = Sd1 / Sds
        if Ta <= Ts:
            Sa = max(Sds * Ie / R, 0.044 * Sds * Ie, 0.01)
        elif Ta <= Tl:
            Sa = max(Sd1 * Ie / Ta / R, 0.044 * Sds * Ie, 0.01)
        else:
            Sa = max(Sd1 * Tl * Ie / (Ta**2) / R, 0.044 * Sds * Ie, 0.01)
        if Ta <= 0.5:
            k = 1.0
        elif Ta <= 2.5:
            k = 0.75 + 0.5 * Ta
        else:
            k = 2.0
        sumH = np.sum(np.power(Loc_heigth, k))

        op.timeSeries('Linear', 3)
        op.pattern('Plain', 3, 1)
        print('Wtotal =', Wtotal)
        Fp = Sa * Wtotal * np.power(Loc_heigth, k) / sumH
        print('FSis =', Fp)
        for fp, ind in zip(Fp, range(len(Loc_heigth))):
            op.load(int(ListNodesDrift[ind, 0]), fp, 0.0, 0.0)
        Vbasal = Sa * Wtotal

        op.analyze(1)
        ElemnsForceDLE = []
        for Element in Elements:
            Forces = op.eleForce(Element.EleTag)
            Forces.insert(0, Element.EleTag)
            ElemnsForceDLE.append(Forces)
        ElemnsForceDLE = np.array(ElemnsForceDLE)
        np.set_printoptions(precision=6)
        np.set_printoptions(suppress=True)

        # Story drift caculations
        DriftMax = 0.02
        nodesDisp = []
        Id_Node_Drift = ListNodesDrift[:, 0]
        Id_Node_Drift = np.int64(Id_Node_Drift)
        Id_Node_Drift = Id_Node_Drift.tolist()
        for nodo in Id_Node_Drift:
            nodesDisp.append([nodo, op.nodeDisp(nodo, 1)])
        nodesDisp = np.array(nodesDisp)
        drift = nodesDisp[1:, 1] - nodesDisp[:-1, 1]
        drift_p = np.divide(drift, np.array(heigth_v))
        ver_drift = np.where(drift_p < DriftMax, 'ok', 'not ok')
        Id_Floor = np.arange(1, len(Loc_heigth))
        drift_table = pd.DataFrame(
            {'1.Floor': Id_Floor, '2.Drift': drift_p * 100, '3.': ver_drift}
        )
        print(drift_table)

        # Beams and columns design procedures
        Beta1B = beta1(fcB)
        cover = 4 * cm
        dst = 3 / 8 * inch
        Ast = pi * dst**2 / 4.0  # area de la barra del estribo
        ro_max_b = 0.85 * Beta1B * fcB * 3.0 / fy / 8.0  # maximun steel percentage
        ro_min_b = max(
            0.25 * sqrt(fcB / MPa) * MPa / fy, 1.4 * MPa / fy
        )  # minimun steel percentage
        DataBeamDesing = []
        for Ele, EleForceD, EleForceDL, EleForceDLE in zip(
            Elements, ElemnsForceD, ElemnsForceDL, ElemnsForceDLE
        ):
            if ListNodes[Ele.Nod_ini, 2] == ListNodes[Ele.Nod_end, 2]:
                VID = EleForceD[2]
                VIL = EleForceDL[2] - VID
                VIE = EleForceDLE[2] - VID - VIL
                VED = abs(EleForceD[5])
                VEL = abs(EleForceDL[5]) - VED
                VEE = abs(EleForceDLE[5]) - VED - VEL

                MID = EleForceD[3] - EleForceD[2] * Ele.RZi
                MIL = EleForceDL[3] - EleForceDL[2] * Ele.RZi - MID
                MIE = EleForceDLE[3] - EleForceDLE[2] * Ele.RZi - MID - MIL
                MED = EleForceD[6] + EleForceD[5] * Ele.RZe
                MEL = EleForceDL[6] + EleForceDL[5] * Ele.RZe - MED
                MEE = EleForceDLE[6] + EleForceDLE[5] * Ele.RZe - MED - MEL
                MED, MEL, MEE = -MED, -MEL, -MEE
                print(
                    'MID ',
                    MID,
                    'MED',
                    MED,
                    'MIL ',
                    MIL,
                    'MEL',
                    MEL,
                    'MIE ',
                    MIE,
                    'MEE',
                    MEE,
                )
                MI1, MI2, MI3, MI4, MI5 = Combo_ACI(MID, MIL, MIE)
                MNU1 = max(
                    [MI1, MI2, MI3, MI4, MI5, 0.0]
                )  # Momento negativo nudo inicial de diseño
                MPU1 = min(
                    [MI1, MI2, MI3, MI4, MI5, abs(MNU1) / 3]
                )  # Momento positivo nudo inicial de diseño
                ME1, ME2, ME3, ME4, ME5 = Combo_ACI(MED, MEL, MEE)
                MNU2 = max(
                    [ME1, ME2, ME3, ME4, ME5, 0.0]
                )  # Momento negativo nudo final de diseño
                MPU2 = min(
                    [ME1, ME2, ME3, ME4, ME5, abs(MNU2) / 3]
                )  # Momento positivo nudo final de diseño
                Mmax = max([MNU1, -MPU1, MNU2, -MPU2])
                MNU1 = max([MNU1, Mmax / 5])
                MPU1 = min([MPU1, -Mmax / 5])
                MNU2 = max([MNU2, Mmax / 5])
                MPU2 = min([MPU2, -Mmax / 5])

                Ast1, dt1, Mn_N1, db_t1 = AsBeam(MNU1, Ele.EleTag)
                Asb1, db1, Mn_P1, db_b1 = AsBeam(MPU1, Ele.EleTag)
                Ast2, dt2, Mn_N2, db_t2 = AsBeam(MNU2, Ele.EleTag)
                Asb2, db2, Mn_P2, db_b2 = AsBeam(MPU2, Ele.EleTag)

                VI1 = 1.2 * VID + 1.6 * VIL
                VI2 = 1.2 * VID + 1.0 * VIL - 1.0 * VIE
                VI3 = 0.9 * VID - 1.0 * VIE
                VI4 = (Mn_P1 + Mn_N2) / Ele.LEle + (1.2 * WDL + WLL) * Ele.LEle / 2.0
                VI5 = (Mn_N1 + Mn_P2) / Ele.LEle + (1.2 * WDL + WLL) * Ele.LEle / 2.0
                VI6 = 1.2 * VID + 1.0 * VIL - 2.0 * VIE
                VI7 = 0.9 * VID - 2.0 * VIE

                VU1a = max(VI1, VI2, VI3)
                VU1b = max(VI4, VI5)
                VU1c = max(VI6, VI7)

                VU1 = max(
                    VU1a, min(VU1b, VU1c)
                )  # Cortante negativo nudo inicial de diseño

                VE1 = 1.2 * VED + 1.6 * VEL
                VE2 = 1.2 * VED + 1.0 * VEL + 1.0 * VEE
                VE3 = 0.9 * VED + 1.0 * VEE
                VE4 = (Mn_P1 + Mn_N2) / Ele.LEle + (1.2 * WDL + WLL) * Ele.LEle / 2.0
                VE5 = (Mn_N1 + Mn_P2) / Ele.LEle + (1.2 * WDL + WLL) * Ele.LEle / 2.0
                VE6 = 1.2 * VED + 1.0 * VEL + 2.0 * VEE
                VE7 = 0.9 * VED + 2.0 * VEE

                VU2a = max(VE1, VE2, VE3)
                VU2b = max(VE4, VE5)
                VU2c = max(VE6, VE7)

                VU2 = max(
                    VU2a, min(VU2b, VU2c)
                )  # Cortante negativo nudo final de diseño

                nst1, sst1 = AvBeam(VU1, db_t1, dt1, Ele.EleTag)
                nst2, sst2 = AvBeam(VU2, db_t2, dt2, Ele.EleTag)

                DataBeamDesing.append(
                    BeamDesing(
                        Ele.EleTag,
                        BBeam,
                        HBeam,
                        Ast1,
                        dt1,
                        Mn_N1,
                        Asb1,
                        db1,
                        Mn_P1,
                        nst1,
                        sst1,
                        Ast2,
                        dt2,
                        Mn_N2,
                        Asb2,
                        db2,
                        Mn_P2,
                        nst2,
                        sst2,
                        Ele.Nod_ini,
                        Ele.Nod_end,
                        db_t1,
                        db_b1,
                        db_t2,
                        db_b2,
                    )
                )
                # self.ui.tbl_data_design_beams.setRowCount(0)
                # data_beams_table(self)

        # Column design procedure
        ro_min = 0.01
        ro_max = 0.08
        Beta1C = beta1(fcC)
        npts = 20
        ncom = 10
        ecu = 0.003
        Es = 200.0 * GPa

        db_v = np.array(
            [5, 6, 7, 8, 9, 10, 11, 14, 18]
        )  # vector de diametros de barras
        DataColDesing = []
        for Ele, EleForceD, EleForceDL, EleForceDLE in zip(
            Elements, ElemnsForceD, ElemnsForceDL, ElemnsForceDLE
        ):
            if ListNodes[Ele.Nod_ini, 1] == ListNodes[Ele.Nod_end, 1]:
                Mn_N_R, Mn_P_R, Mn_N_L, Mn_P_L = 0, 0, 0, 0
                for DB in DataBeamDesing:
                    if Ele.Nod_end == DB.Nod_ini:
                        Mn_N_R, Mn_P_R = DB.Mn_n1, DB.Mn_p1
                    if Ele.Nod_end == DB.Nod_end:
                        Mn_N_L, Mn_P_L = DB.Mn_n2, DB.Mn_p2
                Sum_Mn_B = max(Mn_P_R + Mn_N_L, Mn_N_R + Mn_P_L)
                b, h = Ele.BEle, Ele.HEle
                nbB = ceil(b * 10)  # bars numbers along B
                nbH = ceil(h * 10)  # bars numbers along H
                D_c = 1.1 * h / npts
                nbH_v = np.array([nbH - 1, nbH, nbH + 1])
                nbB_v = np.array([nbB - 1, nbB, nbB + 1])

                MID = EleForceD[3]
                MIL = EleForceDL[3] - MID
                MIE = EleForceDLE[3] - MID - MIL

                PID = EleForceD[2]
                PIL = EleForceDL[2] - PID
                PIE = EleForceDLE[2] - PID - PIL

                MI1, MI2, MI3, MI4, MI5 = Combo_ACI(MID, MIL, MIE)
                PI1, PI2, PI3, PI4, PI5 = Combo_ACI(PID, PIL, PIE)

                MED = -EleForceD[6]
                MEL = -EleForceDL[6] - MED
                MEE = -EleForceDLE[6] - MED - MEL
                print(
                    'MID ',
                    MID,
                    'MED',
                    MED,
                    'MIL ',
                    MIL,
                    'MEL',
                    MEL,
                    'MIE ',
                    MIE,
                    'MEE',
                    MEE,
                )

                PED = -EleForceD[5]
                PEL = -EleForceDL[5] - PED
                PEE = -EleForceDLE[5] - PED - PEL

                ME1, ME2, ME3, ME4, ME5 = Combo_ACI(MED, MEL, MEE)
                PE1, PE2, PE3, PE4, PE5 = Combo_ACI(PED, PEL, PEE)

                Nu_min = min([PI2, PI3, PI4, PI5, PE2, PE3, PE4, PE5])

                Pu_v = np.array([PI1, PI2, PI3, PI4, PI5, PE1, PE2, PE3, PE4, PE5])
                Mu_v = np.array([MI1, MI2, MI3, MI4, MI5, ME1, ME2, ME3, ME4, ME5])
                Mu_v = np.absolute(Mu_v)

                nbH, nbB, db, As, fiPn, fiMn, Mn_i, d, dist, ro, Mu_i = AsColumn()

                VID = EleForceD[1]
                VIL = EleForceDL[1] - VID
                VIE = EleForceDLE[1] - VID - VIL
                VID, VIL, VIE = abs(VID), abs(VIL), abs(VIE)

                Mu_is = Mu_i[[1, 2, 3, 4, 6, 7, 8, 9]]
                Mn_max = np.max(Mu_is)  # Momento maximo de todas las combo sismicas
                VI1, VI2, VI3, VI4, VI5 = Combo_ACI(VID, VIL, VIE)

                VI6 = 2.0 * Mn_max / Ele.LEle
                VI7 = 1.2 * VID + 1.0 * VIL + Omo * VIE
                VI8 = 1.2 * VID + 1.0 * VIL - Omo * VIE
                VI9 = 0.9 * VID + Omo * VIE
                VI10 = 0.9 * VID - Omo * VIE

                VUa = max([VI1, VI2, VI3, VI4, VI5])
                VUb = VI6
                VUc = max([VI7, VI8, VI9, VI10])

                Vu = max([VUa, min([VUb, VUc])])  # Cortante maximo de diseño
                sst, nsB, nsH = AvColumn()
                DataColDesing.append(
                    ColDesing(
                        Ele.EleTag,
                        b,
                        h,
                        nbH,
                        nbB,
                        db,
                        As,
                        Pu_v,
                        Mu_v,
                        fiPn,
                        fiMn,
                        Mn_i,
                        d,
                        dist,
                        ro,
                        Mu_i,
                        sst,
                        nsB,
                        nsH,
                        Ele.Nod_ini,
                        Ele.Nod_end,
                    )
                )

            # self.ui.tbl_data_design_columns.setRowCount(0)
            # data_columns_table(self)
            # self.ui.tabWidget.setCurrentIndex(1)

    # Creation of the nonlinear model
    def CreateNLM(self, rootSIM, outputLogger, preparePushover):
        def __init__(rootSIM):
            self.rootSIM = rootSIM
            self.outputLogger = outputLogger

        global T1m, T2m, EleCol, EleBeam

        # Validation of beam and column design table data
        def validate_data(self):
            cover = 4 * cm
            dst = 3 / 8 * inch

            for DC in DataColDesing:
                dp = cover + dst + 0.5 * DC.db
                DC.dist = np.linspace(dp, DC.h - dp, DC.nbH)
                Ab = pi * DC.db**2.0 / 4.0
                DC.As = np.hstack(
                    [DC.nbB * Ab, np.ones(DC.nbH - 2) * 2 * Ab, DC.nbB * Ab]
                )

                # print("DC.EleTag",DC.EleTag)
                # print("DC.nbH",DC.nbH)
                # print("DC.db",DC.db)
                # print("Ab",Ab)
                # print("DC.nbB",DC.nbB)
                # print("DC.h",DC.h)
                # print("DC.b",DC.b)
                # print("dp",dp)
                # print("dst",dst)
                # print("cover",cover)
                # print("DC.As",DC.As)
                # print("DC.dist",DC.dist)

        # Function: Parameters of regularized unconfined concrete
        def con_inconf_regu():
            fpc = -fc
            epsc0 = 2 * fpc / Ec
            Gfc = max(2.0 * (-fpc / MPa) * N / mm, 25.0 * N / mm)
            epscu = Gfc / (0.6 * fpc * phl) - 0.8 * fpc / Ec + epsc0
            fcu = 0.2 * fpc
            lambdaU = 0.10
            ft = 0.33 * sqrt(-fpc * MPa)
            Ets = ft / 0.002
            return fpc, epsc0, fcu, epscu, lambdaU, ft, Ets

        # Function: Parameters of regularized confined concrete
        def con_conf_regu(b, h, nsB, nsH, sst):
            fpc = -fc
            bcx = h - 2.0 * cover - dst
            bcy = b - 2.0 * cover - dst
            Asx = nsB * Ast
            Asy = nsH * Ast
            Asvt = Asx + Asy
            flx = Asvt * fy / sst / bcx
            fly = Asvt * fy / sst / bcy
            slx = bcx / (nsB - 1)
            sly = bcy / (nsH - 1)
            k2x = min(0.26 * sqrt((bcx / sst) * (bcx / slx) * (1000.0 / flx)), 1)
            k2y = min(0.26 * sqrt((bcy / sst) * (bcy / sly) * (1000.0 / fly)), 1)
            flex = k2x * flx
            fley = k2y * fly
            fle = (flex * bcx + fley * bcy) / (bcx + bcy)
            k1 = 6.7 * (fle / 1000.0) ** (-0.17)
            fcc = fc + k1 * fle
            fpcc = -fcc
            Ecc = Ec
            Gfc = max(2.0 * (-fpc / MPa) * N / mm, 25.0 * N / mm)
            K = k1 * fle / fc
            epscc0 = eo1 * (1.0 + 5.0 * K)
            Gfcc = 1.7 * Gfc
            epsccu = Gfcc / (0.6 * fpcc * phl) - 0.8 * fpcc / Ecc + epscc0
            fccu = 0.2 * fpcc
            lambdaC = 0.10
            ft = 0.33 * sqrt(-fpc * MPa)
            Ets = ft / 0.002

            #            print("**** sst",sst)
            #            print("**** fpc",fpc)
            #            print("**** bcx",bcx)
            #            print("**** bcy",bcy)
            #            print("**** Asx",Asx)
            #            print("**** Asy",Asy)
            #            print("**** Asvt",Asvt)
            #            print("**** flx",flx)
            #            print("**** fly",fly)
            #            print("**** slx",slx)
            #            print("**** sly",sly)
            #            print("**** k2x",k2x)
            #            print("**** k2y",k2y)
            #            print("**** flex",flex)
            #            print("**** fley",fley)
            #            print("**** fle",fle)
            #            print("**** k1",k1)
            #            print("**** fcc",fcc)
            #            print("**** fpcc",fpcc)
            #            print("**** Ecc",Ecc)
            #            print("**** Gfc",Gfc)
            #            print("**** K",K)
            #            print("**** epscc0",epscc0)
            #            print("**** Gfcc",Gfcc)
            #            print("**** epsccu",epsccu)
            #            print("**** fccu",fccu)
            #            print("**** lambdaC",lambdaC)
            #            print("**** ft",ft)
            #            print("**** Ets",Ets)

            return fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets

        # Function: Regularized steel parameters
        def steel_mat_regu():
            FyTestN4 = 490.0 * MPa
            FsuTestN4 = 630.0 * MPa
            epsuTestN4 = 0.10
            LgageTestN4 = 200.0 * mm
            Es = 200.0 * GPa
            FyPosN4 = FyTestN4
            epsyPosN4 = FyPosN4 / Es
            FyNegN4 = FyTestN4
            epsyNegN4 = FyNegN4 / Es
            FsuPosN4 = FsuTestN4
            epsuPosN4 = epsyPosN4 + LgageTestN4 / phl * (epsuTestN4 - epsyPosN4)
            bPosN4 = (FsuPosN4 - FyPosN4) / (Es * (epsuPosN4 - epsyPosN4))
            epsuNegN4 = min(-epsccu, epsuPosN4)
            bNegN4 = bPosN4
            # FsuNegN4 = FsuTestN4
            FsuNegN4 = FyNegN4 + bNegN4 * (Es * (epsuNegN4 - epsyNegN4))
            FsrPosN4 = 0.2 * FyPosN4
            epsrPosN4 = (FsuPosN4 - FsrPosN4) / Es + 1.05 * epsuPosN4
            FsrNegN4 = 0.2 * FsuNegN4
            epsrNegN4 = (FsuNegN4 - FsrNegN4) / Es + 1.05 * epsuNegN4
            pinchX = 0.2
            pinchY = 0.8
            damage1 = 0.0
            damage2 = 0.0
            beta = 0.0
            # op.uniaxialMaterial('Hysteretic', Ele.EleTag * 6 + 4 + pos, FyPosN4, epsyPosN4, FsuPosN4, epsuPosN4
            #                     , FsrPosN4, epsrPosN4, -FyNegN4, -epsyNegN4, -FsuNegN4, -epsuNegN4, -FsrNegN4
            #                     , -epsrNegN4, pinchX, pinchY, damage1, damage2, beta)

            SteelN4Mat = Ele.EleTag * 6 + 4 + pos
            SteelMPFTag = 1e6 * SteelN4Mat
            R0 = 20.0
            cR1 = 0.925
            cR2 = 0.15
            a1 = 0.0
            a2 = 1.0
            a3 = 0.0
            a4 = 0.0
            print(
                'SteelMPF',
                int(SteelMPFTag),
                FyPosN4,
                FyNegN4,
                Es,
                bPosN4,
                bNegN4,
                R0,
                cR1,
                cR2,
                a1,
                a2,
                a3,
                a4,
            )
            op.uniaxialMaterial(
                'SteelMPF',
                SteelMPFTag,
                FyPosN4,
                FyNegN4,
                Es,
                bPosN4,
                bNegN4,
                R0,
                cR1,
                cR2,
                a1,
                a2,
                a3,
                a4,
            )
            outputLogger.add_array(
                [
                    'uniaxialMaterial',
                    'SteelMPF',
                    int(SteelMPFTag),
                    FyPosN4,
                    FyNegN4,
                    Es,
                    bPosN4,
                    bNegN4,
                    R0,
                    cR1,
                    cR2,
                    a1,
                    a2,
                    a3,
                    a4,
                ]
            )

            print(
                'MinMax',
                int(SteelN4Mat),
                int(SteelMPFTag),
                '-min',
                -epsuNegN4,
                '-max',
                epsuPosN4,
            )
            op.uniaxialMaterial(
                'MinMax',
                SteelN4Mat,
                SteelMPFTag,
                '-min',
                -epsuNegN4,
                '-max',
                epsuPosN4,
            )
            outputLogger.add_array(
                [
                    'uniaxialMaterial',
                    'MinMax',
                    int(SteelN4Mat),
                    int(SteelMPFTag),
                    '-min',
                    -epsuNegN4,
                    '-max',
                    epsuPosN4,
                ]
            )

        # Function: Parameters of non-regularized confined concrete
        def con_conf(b, h, nsB, nsH, sst):
            fpc = -fc
            bcx = h - 2.0 * cover - dst
            bcy = b - 2.0 * cover - dst
            Asx = nsB * Ast
            Asy = nsH * Ast
            Asvt = Asx + Asy
            flx = Asvt * fy / sst / bcx
            fly = Asvt * fy / sst / bcy
            slx = bcx / (nsB - 1)
            sly = bcy / (nsH - 1)
            k2x = min(0.26 * sqrt((bcx / sst) * (bcx / slx) * (1000.0 / flx)), 1)
            k2y = min(0.26 * sqrt((bcy / sst) * (bcy / sly) * (1000.0 / fly)), 1)
            flex = k2x * flx
            fley = k2y * fly
            fle = (flex * bcx + fley * bcy) / (bcx + bcy)
            k1 = 6.7 * (fle / 1000.0) ** (-0.17)
            fcc = fc + k1 * fle
            fpcc = -fcc
            K = k1 * fle / fc
            epscc0 = eo1 * (1.0 + 5.0 * K)
            rov = Asvt / sst / (bcx + bcy)
            e85 = 260 * rov * epscc0 + eo85
            epsccu = (e85 - epscc0) * (0.2 * fcc - fcc) / (0.85 * fcc - fcc) + epscc0
            fccu = 0.2 * fpcc
            lambdaC = 0.10
            ft = 0.33 * sqrt(-fpc * MPa)
            Ets = ft / 0.002
            return fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets

        # Function: Parameters of non-regularized steel
        def steel_mat():
            FyTestN4 = 490.0 * MPa
            FsuTestN4 = 630.0 * MPa
            epsuTestN4 = 0.10
            LgageTestN4 = phl
            Es = 200.0 * GPa
            FyPosN4 = FyTestN4
            epsyPosN4 = FyPosN4 / Es
            FyNegN4 = FyTestN4
            epsyNegN4 = FyNegN4 / Es
            FsuPosN4 = FsuTestN4
            epsuPosN4 = epsyPosN4 + LgageTestN4 / phl * (epsuTestN4 - epsyPosN4)
            bPosN4 = (FsuPosN4 - FyPosN4) / (Es * (epsuPosN4 - epsyPosN4))
            epsuNegN4 = min(-epsccu, epsuPosN4)
            bNegN4 = bPosN4
            # FsuNegN4 = FsuTestN4
            FsuNegN4 = FyNegN4 + bNegN4 * (Es * (epsuNegN4 - epsyNegN4))
            FsrPosN4 = 0.2 * FyPosN4
            epsrPosN4 = (FsuPosN4 - FsrPosN4) / Es + 1.05 * epsuPosN4
            FsrNegN4 = 0.2 * FsuNegN4
            epsrNegN4 = (FsuNegN4 - FsrNegN4) / Es + 1.05 * epsuNegN4
            pinchX = 0.2
            pinchY = 0.8
            damage1 = 0.0
            damage2 = 0.0
            beta = 0.0
            # op.uniaxialMaterial('Hysteretic', Ele.EleTag * 6 + 4 + pos, FyPosN4, epsyPosN4, FsuPosN4, epsuPosN4
            #                     , FsrPosN4, epsrPosN4, -FyNegN4, -epsyNegN4, -FsuNegN4, -epsuNegN4, -FsrNegN4
            #                     , -epsrNegN4, pinchX, pinchY, damage1, damage2, beta)

            SteelN4Mat = Ele.EleTag * 6 + 4 + pos
            SteelMPFTag = 1e6 * SteelN4Mat
            R0 = 20.0
            cR1 = 0.925
            cR2 = 0.15
            a1 = 0.0
            a2 = 1.0
            a3 = 0.0
            a4 = 0.0
            print(
                'SteelMPF',
                int(SteelMPFTag),
                FyPosN4,
                FyNegN4,
                Es,
                bPosN4,
                bNegN4,
                R0,
                cR1,
                cR2,
                a1,
                a2,
                a3,
                a4,
            )
            op.uniaxialMaterial(
                'SteelMPF',
                SteelMPFTag,
                FyPosN4,
                FyNegN4,
                Es,
                bPosN4,
                bNegN4,
                R0,
                cR1,
                cR2,
                a1,
                a2,
                a3,
                a4,
            )
            outputLogger.add_array(
                [
                    'uniaxialMaterial',
                    'SteelMPF',
                    int(SteelMPFTag),
                    FyPosN4,
                    FyNegN4,
                    Es,
                    bPosN4,
                    bNegN4,
                    R0,
                    cR1,
                    cR2,
                    a1,
                    a2,
                    a3,
                    a4,
                ]
            )

            print(
                'MinMax',
                int(SteelN4Mat),
                int(SteelMPFTag),
                '-min',
                -epsuNegN4,
                '-max',
                epsuPosN4,
            )
            op.uniaxialMaterial(
                'MinMax',
                SteelN4Mat,
                SteelMPFTag,
                '-min',
                -epsuNegN4,
                '-max',
                epsuPosN4,
            )
            outputLogger.add_array(
                [
                    'uniaxialMaterial',
                    'MinMax',
                    int(SteelN4Mat),
                    int(SteelMPFTag),
                    '-min',
                    -epsuNegN4,
                    '-max',
                    epsuPosN4,
                ]
            )

        # Function: Creation of fibers in beams
        def fiber_beam(Ast, Asb, pos):
            op.section('Fiber', Ele.EleTag * 2 + pos)
            op.patch(
                'rect',
                Ele.EleTag * 6 + pos,
                10,
                1,
                -y2 + dp,
                -z2 + dp,
                y2 - dp,
                z2 - dp,
            )
            op.patch(
                'rect',
                Ele.EleTag * 6 + 2 + pos,
                10,
                1,
                -y2 + dp,
                z2 - dp,
                y2 - dp,
                z2,
            )
            op.patch(
                'rect',
                Ele.EleTag * 6 + 2 + pos,
                10,
                1,
                -y2 + dp,
                -z2,
                y2 - dp,
                -z2 + dp,
            )
            op.patch('rect', Ele.EleTag * 6 + 2 + pos, 2, 1, -y2, -z2, -y2 + dp, z2)
            op.patch('rect', Ele.EleTag * 6 + 2 + pos, 2, 1, y2 - dp, -z2, y2, z2)
            print(
                'BeamL',
                Ele.EleTag * 6 + 4 + pos,
                1,
                Ast,
                y2 - dp,
                z2 - dp,
                y2 - dp,
                -z2 + dp,
            )
            op.layer(
                'straight',
                Ele.EleTag * 6 + 4 + pos,
                1,
                Ast,
                y2 - dp,
                z2 - dp,
                y2 - dp,
                -z2 + dp,
            )
            print(
                'BeamR',
                Ele.EleTag * 6 + 4 + pos,
                1,
                Asb,
                -y2 + dp,
                z2 - dp,
                -y2 + dp,
                -z2 + dp,
            )
            op.layer(
                'straight',
                Ele.EleTag * 6 + 4 + pos,
                1,
                Asb,
                -y2 + dp,
                z2 - dp,
                -y2 + dp,
                -z2 + dp,
            )

            outputLogger.add_line('# Creating fibres in beam')

            outputLogger.add_array(['section', 'Fiber', Ele.EleTag * 2 + pos, '{'])
            outputLogger.add_array(
                [
                    'patch',
                    'rect',
                    Ele.EleTag * 6 + pos,
                    10,
                    1,
                    -y2 + dp,
                    -z2 + dp,
                    y2 - dp,
                    z2 - dp,
                ]
            )
            outputLogger.add_array(
                [
                    'patch',
                    'rect',
                    Ele.EleTag * 6 + 2 + pos,
                    10,
                    1,
                    -y2 + dp,
                    z2 - dp,
                    y2 - dp,
                    z2,
                ]
            )
            outputLogger.add_array(
                [
                    'patch',
                    'rect',
                    Ele.EleTag * 6 + 2 + pos,
                    10,
                    1,
                    -y2 + dp,
                    -z2,
                    y2 - dp,
                    -z2 + dp,
                ]
            )
            outputLogger.add_array(
                [
                    'patch',
                    'rect',
                    Ele.EleTag * 6 + 2 + pos,
                    2,
                    1,
                    -y2,
                    -z2,
                    -y2 + dp,
                    z2,
                ]
            )
            outputLogger.add_array(
                [
                    'patch',
                    'rect',
                    Ele.EleTag * 6 + 2 + pos,
                    2,
                    1,
                    y2 - dp,
                    -z2,
                    y2,
                    z2,
                ]
            )
            outputLogger.add_array(
                [
                    'layer',
                    'straight',
                    Ele.EleTag * 6 + 4 + pos,
                    1,
                    Ast,
                    y2 - dp,
                    z2 - dp,
                    y2 - dp,
                    -z2 + dp,
                ]
            )
            outputLogger.add_array(
                [
                    'layer',
                    'straight',
                    Ele.EleTag * 6 + 4 + pos,
                    1,
                    Asb,
                    -y2 + dp,
                    z2 - dp,
                    -y2 + dp,
                    -z2 + dp,
                ]
            )
            outputLogger.add_line('}')

        validate_data(self)
        op.wipe()  # The models is restarted in opensees
        outputLogger.add_line('wipe;')

        op.model('Basic', '-ndm', 2, '-ndf', 3)
        outputLogger.add_array(['model', 'Basic', '-ndm', 2, '-ndf', 3])

        outputLogger.add_line('# Create the nodes')

        for node in ListNodes:
            op.node(int(node[0]), int(node[1]), int(node[2]))
            outputLogger.add_array(
                ['node', int(node[0]), int(node[1]), int(node[2])]
            )

            if node[2] == 0.0:
                op.fix(int(node[0]), 1, 1, 1)
                outputLogger.add_array(['fix', int(node[0]), 1, 1, 1])
            if node[2] > 0 and node[1] == 0:
                MasterNode = node[0]
            if node[2] > 0 and node[1] != 0:
                op.equalDOF(int(MasterNode), int(node[0]), 1)
                outputLogger.add_array(
                    ['equalDOF', int(MasterNode), int(node[0]), 1]
                )

        cover = 4 * cm
        dst = 3 / 8 * inch
        Ast = pi * dst**2 / 4.0  # area de la barra del estribo

        # creacion de columnas
        # HBeam = float(self.ui.HBeam.text())
        HBeam = float(rootSIM['BeamDepth'])

        # HColi = float(self.ui.HColi.text())  # Column inside Depth
        HColi = float(rootSIM['IntColDepth'])

        # HCole = float(self.ui.HCole.text())  # Column outside Depth
        HCole = float(rootSIM['ExtColDepth'])

        # fy = float(self.ui.fy.text()) * MPa
        fy = float(rootSIM['FySteel']) * MPa

        Es = 200.0 * GPa

        # fcB = float(self.ui.fcB.text()) * MPa
        fcB = float(rootSIM['BeamFpc']) * MPa

        # fcC = float(self.ui.fcC.text()) * MPa
        fcC = float(rootSIM['ColFpc']) * MPa

        op.geomTransf('PDelta', 1, '-jntOffset', 0, 0, 0, -HBeam / 2)
        op.geomTransf('PDelta', 2, '-jntOffset', 0, HBeam / 2, 0, -HBeam / 2)
        op.geomTransf(
            'Corotational', 3, '-jntOffset', HColi / 2.0, 0, -HColi / 2.0, 0
        )
        op.geomTransf(
            'Corotational', 4, '-jntOffset', HCole / 2.0, 0, -HColi / 2.0, 0
        )
        op.geomTransf(
            'Corotational', 5, '-jntOffset', HColi / 2.0, 0, -HCole / 2.0, 0
        )

        outputLogger.add_line('# Define the geometric transformations')

        outputLogger.add_array(
            ['geomTransf', 'PDelta', 1, '-jntOffset', 0, 0, 0, -HBeam / 2]
        )
        outputLogger.add_array(
            ['geomTransf', 'PDelta', 2, '-jntOffset', 0, HBeam / 2, 0, -HBeam / 2]
        )
        outputLogger.add_array(
            [
                'geomTransf',
                'Corotational',
                3,
                '-jntOffset',
                HColi / 2.0,
                0,
                -HColi / 2.0,
                0,
            ]
        )
        outputLogger.add_array(
            [
                'geomTransf',
                'Corotational',
                4,
                '-jntOffset',
                HCole / 2.0,
                0,
                -HColi / 2.0,
                0,
            ]
        )
        outputLogger.add_array(
            [
                'geomTransf',
                'Corotational',
                5,
                '-jntOffset',
                HColi / 2.0,
                0,
                -HCole / 2.0,
                0,
            ]
        )

        EleCol = []
        EleBeam = []
        for Ele in Elements:
            if ListNodes[Ele.Nod_ini, 1] == ListNodes[Ele.Nod_end, 1]:
                EleCol.append(Ele)
            else:
                EleBeam.append(Ele)

        platicHingeOpt = int(rootSIM['PlasticHingeOpt'])
        includeRegularization = bool(rootSIM['IncludeRegularization'])

        # print("platicHingeOpt",platicHingeOpt)
        # print("includeRegularization",includeRegularization)

        # Creation of non-linear elements (beams and columns)
        eo1, eo85, eo20, lambdaU = -0.002, -0.0038, -0.006, 0.1
        for Ele, DC in zip(EleCol, DataColDesing):
            outputLogger.add_line(
                '# Creating materials and elements for column ' + str(DC.EleTag)
            )

            fc, Ec = fcC, Ele.EcEle
            if platicHingeOpt == 1:
                phl = 0.5 * DC.h
            elif platicHingeOpt == 2:
                phl = 0.08 * Ele.LEle + 0.022 * fy / MPa * DC.db / mm
            elif platicHingeOpt == 3:
                phl = 0.05 * Ele.LEle + 0.1 * fy / MPa * DC.db / mm / sqrt(fc * MPa)

            if includeRegularization == True:
                fpc, epsc0, fcu, epscu, lambdaU, ft, Ets = con_inconf_regu()
                print(
                    'Concrete02',
                    Ele.EleTag * 6,
                    fpc,
                    epsc0,
                    fcu,
                    epscu,
                    lambdaU,
                    ft,
                    Ets,
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6,
                    fpc,
                    epsc0,
                    fcu,
                    epscu,
                    lambdaU,
                    ft,
                    Ets,
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 1,
                    fpc,
                    epsc0,
                    fcu,
                    epscu,
                    lambdaU,
                    ft,
                    Ets,
                )

                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6,
                        fpc,
                        epsc0,
                        fcu,
                        epscu,
                        lambdaU,
                        ft,
                        Ets,
                    ]
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 1,
                        fpc,
                        epsc0,
                        fcu,
                        epscu,
                        lambdaU,
                        ft,
                        Ets,
                    ]
                )

                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf_regu(
                    DC.b, DC.h, DC.nsB, DC.nsH, DC.sst
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 2,
                    fpcc,
                    epscc0,
                    fccu,
                    epsccu,
                    lambdaC,
                    ft,
                    Ets,
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 3,
                    fpcc,
                    epscc0,
                    fccu,
                    epsccu,
                    lambdaC,
                    ft,
                    Ets,
                )

                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 2,
                        fpcc,
                        epscc0,
                        fccu,
                        epsccu,
                        lambdaC,
                        ft,
                        Ets,
                    ]
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 3,
                        fpcc,
                        epscc0,
                        fccu,
                        epsccu,
                        lambdaC,
                        ft,
                        Ets,
                    ]
                )

                pos = 0
                steel_mat_regu()
                pos = 1
                steel_mat_regu()
            # No regularization
            else:
                ft = 0.33 * sqrt(fcC * MPa)
                Ets = ft / 0.002
                print(
                    'Concrete02',
                    Ele.EleTag * 6,
                    -fcC,
                    eo1,
                    -0.2 * fcC,
                    eo20,
                    lambdaU,
                    ft,
                    Ets,
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6,
                    -fcC,
                    eo1,
                    -0.2 * fcC,
                    eo20,
                    lambdaU,
                    ft,
                    Ets,
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 1,
                    -fcC,
                    eo1,
                    -0.2 * fcC,
                    eo20,
                    lambdaU,
                    ft,
                    Ets,
                )

                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6,
                        -fcC,
                        eo1,
                        -0.2 * fcC,
                        eo20,
                        lambdaU,
                        ft,
                        Ets,
                    ]
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 1,
                        -fcC,
                        eo1,
                        -0.2 * fcC,
                        eo20,
                        lambdaU,
                        ft,
                        Ets,
                    ]
                )

                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf(
                    DC.b, DC.h, DC.nsB, DC.nsH, DC.sst
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 2,
                    fpcc,
                    epscc0,
                    fccu,
                    epsccu,
                    lambdaC,
                    ft,
                    Ets,
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 3,
                    fpcc,
                    epscc0,
                    fccu,
                    epsccu,
                    lambdaC,
                    ft,
                    Ets,
                )

                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 2,
                        fpcc,
                        epscc0,
                        fccu,
                        epsccu,
                        lambdaC,
                        ft,
                        Ets,
                    ]
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 3,
                        fpcc,
                        epscc0,
                        fccu,
                        epsccu,
                        lambdaC,
                        ft,
                        Ets,
                    ]
                )

                pos = 0
                steel_mat()
                pos = 1
                steel_mat()

            dp = DC.dist[0]
            y1 = DC.h / 2.0
            z1 = DC.b / 2.0

            outputLogger.add_line(
                '# Creating sections and fibres for element ' + str(Ele.EleTag)
            )

            op.section('Fiber', Ele.EleTag)
            op.patch(
                'rect',
                Ele.EleTag * 6 + 2,
                10,
                1,
                -y1 + dp,
                -z1 + dp,
                y1 - dp,
                z1 - dp,
            )
            op.patch('rect', Ele.EleTag * 6, 10, 1, -y1 + dp, z1 - dp, y1 - dp, z1)
            op.patch('rect', Ele.EleTag * 6, 10, 1, -y1 + dp, -z1, y1 - dp, -z1 + dp)
            op.patch('rect', Ele.EleTag * 6, 2, 1, -y1, -z1, -y1 + dp, z1)
            op.patch('rect', Ele.EleTag * 6, 2, 1, y1 - dp, -z1, y1, z1)

            outputLogger.add_array(['section', 'Fiber', int(Ele.EleTag), '{'])
            outputLogger.add_array(
                [
                    'patch',
                    'rect',
                    Ele.EleTag * 6 + 2,
                    10,
                    1,
                    -y1 + dp,
                    -z1 + dp,
                    y1 - dp,
                    z1 - dp,
                ]
            )
            outputLogger.add_array(
                [
                    'patch',
                    'rect',
                    Ele.EleTag * 6,
                    10,
                    1,
                    -y1 + dp,
                    z1 - dp,
                    y1 - dp,
                    z1,
                ]
            )
            outputLogger.add_array(
                [
                    'patch',
                    'rect',
                    Ele.EleTag * 6,
                    10,
                    1,
                    -y1 + dp,
                    -z1,
                    y1 - dp,
                    -z1 + dp,
                ]
            )
            outputLogger.add_array(
                ['patch', 'rect', Ele.EleTag * 6, 2, 1, -y1, -z1, -y1 + dp, z1]
            )
            outputLogger.add_array(
                ['patch', 'rect', Ele.EleTag * 6, 2, 1, y1 - dp, -z1, y1, z1]
            )

            for dist, As in zip(DC.dist, DC.As):
                print(
                    'Col ',
                    Ele.EleTag * 6 + 4,
                    1,
                    As,
                    -y1 + dist,
                    z1 - dp,
                    -y1 + dist,
                    -z1 + dp,
                )
                op.layer(
                    'straight',
                    Ele.EleTag * 6 + 4,
                    1,
                    As,
                    -y1 + dist,
                    z1 - dp,
                    -y1 + dist,
                    -z1 + dp,
                )
                outputLogger.add_array(
                    [
                        'layer',
                        'straight',
                        Ele.EleTag * 6 + 4,
                        1,
                        As,
                        -y1 + dist,
                        z1 - dp,
                        -y1 + dist,
                        -z1 + dp,
                    ]
                )

            outputLogger.add_line('}')

            MassDens = Ele.AEle * GConc / g
            op.beamIntegration(
                'HingeRadau',
                Ele.EleTag,
                Ele.EleTag,
                phl,
                Ele.EleTag,
                phl,
                Ele.EleTag,
            )

            # outputLogger.add_array(['beamIntegration','HingeRadau', Ele.EleTag, Ele.EleTag, phl, Ele.EleTag, phl, Ele.EleTag])

            op.element(
                'forceBeamColumn',
                Ele.EleTag,
                Ele.Nod_ini,
                Ele.Nod_end,
                Ele.ElegTr,
                Ele.EleTag,
                '-mass',
                MassDens,
            )

            intgrStr = (
                '"HingeRadau'
                + ' '
                + str(Ele.EleTag)
                + ' '
                + str(phl)
                + ' '
                + str(Ele.EleTag)
                + ' '
                + str(phl)
                + ' '
                + str(Ele.EleTag)
                + '"'
            )
            outputLogger.add_array(
                [
                    'element',
                    'forceBeamColumn',
                    Ele.EleTag,
                    Ele.Nod_ini,
                    Ele.Nod_end,
                    Ele.ElegTr,
                    intgrStr,
                    '-mass',
                    MassDens,
                ]
            )

        for Ele, DB in zip(EleBeam, DataBeamDesing):
            fc, Ec, nsH = fcB, Ele.EcEle, 2
            if platicHingeOpt == 1:
                phl1 = 0.5 * DB.h
                phl2 = 0.5 * DB.h
            elif platicHingeOpt == 2:
                phl1 = 0.08 * Ele.LEle + 0.022 * fy / MPa * DB.db_t1 / mm
                phl2 = 0.08 * Ele.LEle + 0.022 * fy / MPa * DB.db_t2 / mm
            elif platicHingeOpt == 3:
                phl1 = 0.05 * Ele.LEle + 0.1 * fy / MPa * DB.db_t1 / mm / sqrt(
                    fc * MPa
                )
                phl2 = 0.05 * Ele.LEle + 0.1 * fy / MPa * DB.db_t2 / mm / sqrt(
                    fc * MPa
                )

            outputLogger.add_line(
                '# Creating materials and elements for beam ' + str(DB.EleTag)
            )

            if includeRegularization == True:
                phl = phl1
                fpc, epsc0, fcu, epscu, lambdaU, ft, Ets = con_inconf_regu()
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6,
                    fpc,
                    epsc0,
                    fcu,
                    epscu,
                    lambdaU,
                    ft,
                    Ets,
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6,
                        fpc,
                        epsc0,
                        fcu,
                        epscu,
                        lambdaU,
                        ft,
                        Ets,
                    ]
                )

                phl = phl2
                fpc, epsc0, fcu, epscu, lambdaU, ft, Ets = con_inconf_regu()
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 1,
                    fpc,
                    epsc0,
                    fcu,
                    epscu,
                    lambdaU,
                    ft,
                    Ets,
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 1,
                        fpc,
                        epsc0,
                        fcu,
                        epscu,
                        lambdaU,
                        ft,
                        Ets,
                    ]
                )

                phl, pos = phl1, 0
                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf_regu(
                    DB.b, DB.h, DB.ns1, nsH, DB.ss1
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 2,
                    fpcc,
                    epscc0,
                    fccu,
                    epsccu,
                    lambdaC,
                    ft,
                    Ets,
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 2,
                        fpcc,
                        epscc0,
                        fccu,
                        epsccu,
                        lambdaC,
                        ft,
                        Ets,
                    ]
                )

                steel_mat_regu()
                phl, pos = phl2, 1
                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf_regu(
                    DB.b, DB.h, DB.ns2, nsH, DB.ss2
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 3,
                    fpcc,
                    epscc0,
                    fccu,
                    epsccu,
                    lambdaC,
                    ft,
                    Ets,
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 3,
                        fpcc,
                        epscc0,
                        fccu,
                        epsccu,
                        lambdaC,
                        ft,
                        Ets,
                    ]
                )

                steel_mat_regu()
            # No regularization
            else:
                ft = 0.33 * sqrt(fcB * MPa)
                Ets = ft / 0.002
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6,
                    -fcB,
                    eo1,
                    -0.2 * fcB,
                    eo20,
                    lambdaU,
                    ft,
                    Ets,
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 1,
                    -fcB,
                    eo1,
                    -0.2 * fcB,
                    eo20,
                    lambdaU,
                    ft,
                    Ets,
                )

                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6,
                        -fcB,
                        eo1,
                        -0.2 * fcB,
                        eo20,
                        lambdaU,
                        ft,
                        Ets,
                    ]
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 1,
                        -fcB,
                        eo1,
                        -0.2 * fcB,
                        eo20,
                        lambdaU,
                        ft,
                        Ets,
                    ]
                )

                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf(
                    DB.b, DB.h, DB.ns1, nsH, DB.ss1
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 2,
                    fpcc,
                    epscc0,
                    fccu,
                    epsccu,
                    lambdaC,
                    ft,
                    Ets,
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 2,
                        fpcc,
                        epscc0,
                        fccu,
                        epsccu,
                        lambdaC,
                        ft,
                        Ets,
                    ]
                )

                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf(
                    DB.b, DB.h, DB.ns2, nsH, DB.ss2
                )
                op.uniaxialMaterial(
                    'Concrete02',
                    Ele.EleTag * 6 + 3,
                    fpcc,
                    epscc0,
                    fccu,
                    epsccu,
                    lambdaC,
                    ft,
                    Ets,
                )
                outputLogger.add_array(
                    [
                        'uniaxialMaterial',
                        'Concrete02',
                        Ele.EleTag * 6 + 3,
                        fpcc,
                        epscc0,
                        fccu,
                        epsccu,
                        lambdaC,
                        ft,
                        Ets,
                    ]
                )

                pos = 0
                steel_mat()
                pos = 1
                steel_mat()
            y2 = DB.h / 2.0
            z2 = DB.b / 2.0
            dp = DB.h - min(DB.db1, DB.dt1)
            pos = 0

            fiber_beam(DB.Ast1, DB.Asb1, pos)
            dp = DB.h - min(DB.db2, DB.dt2)
            pos = 1
            fiber_beam(DB.Ast2, DB.Asb2, pos)
            MassDens = Ele.AEle * GConc / g + WDLS / g
            op.beamIntegration(
                'HingeRadau',
                Ele.EleTag,
                Ele.EleTag * 2,
                phl1,
                Ele.EleTag * 2 + 1,
                phl2,
                Ele.EleTag * 2,
            )
            # outputLogger.add_array(['beamIntegration','HingeRadau', Ele.EleTag, Ele.EleTag * 2, phl1, Ele.EleTag * 2 + 1, phl2, Ele.EleTag * 2])

            op.element(
                'forceBeamColumn',
                Ele.EleTag,
                Ele.Nod_ini,
                Ele.Nod_end,
                Ele.ElegTr,
                Ele.EleTag,
                '-mass',
                MassDens,
            )

            intgrStr = (
                '"HingeRadau'
                + ' '
                + str(Ele.EleTag * 2)
                + ' '
                + str(phl1)
                + ' '
                + str(Ele.EleTag * 2 + 1)
                + ' '
                + str(phl2)
                + ' '
                + str(Ele.EleTag * 2)
                + '"'
            )
            outputLogger.add_array(
                [
                    'element',
                    'forceBeamColumn',
                    Ele.EleTag,
                    Ele.Nod_ini,
                    Ele.Nod_end,
                    Ele.ElegTr,
                    intgrStr,
                    '-mass',
                    MassDens,
                ]
            )

        list_beams = [Ele.EleTag for Ele in EleBeam]
        list_cols = [Ele.EleTag for Ele in EleCol]
        print('list_beams =', list_beams)
        print('list_cols =', list_cols)

        print('Model Nonlinear Built')

        # KZ: gravity analysis
        outputLogger.add_array(['timeSeries Linear 1'])
        outputLogger.add_array(['pattern Plain 1 Constant {'])
        for Ele in EleCol:
            outputLogger.add_array(
                [
                    'eleLoad -ele {} -type -beamUniform 0 {}'.format(
                        Ele.EleTag, -Ele.AEle * GConc
                    )
                ]
            )
        for Ele in EleBeam:
            outputLogger.add_array(
                [
                    'eleLoad -ele {} -type -beamUniform {}'.format(
                        Ele.EleTag, -Ele.AEle * GConc - WDL
                    )
                ]
            )
        outputLogger.add_array(['}'])
        outputLogger.add_array(['set Tol 1.0e-6'])
        outputLogger.add_array(['constraints Plain'])
        outputLogger.add_array(['numberer Plain'])
        outputLogger.add_array(['system BandGeneral'])
        outputLogger.add_array(['test NormDispIncr 1e-6 100'])
        outputLogger.add_array(['algorithm KrylovNewton'])
        outputLogger.add_array(['integrator LoadControl 0.1'])
        outputLogger.add_array(['analysis Static'])
        outputLogger.add_array(['analyze 10'])
        outputLogger.add_array(['loadConst -time 0.0'])

        # KZ: user defined damping
        xi = rootSIM.get('dampingRatio', 0.05)
        # KZ: modes
        if rootSIM.get('Simulation', None) is not None:
            tmp = rootSIM.get('Simulation')
            mode1 = tmp.get('firstMode', 1)
            mode2 = tmp.get('secnondMode', 3)
        else:
            mode1 = 1
            mode2 = 3
        outputLogger.add_array(['set nEigenI {}'.format(mode1)])
        outputLogger.add_array(['set nEigenJ {}'.format(mode2)])
        outputLogger.add_array(['set lambdaN [eigen [expr $nEigenJ]]'])
        outputLogger.add_array(['set lambdaI [lindex $lambdaN [expr $nEigenI-1]]'])
        outputLogger.add_array(['set lambdaJ [lindex $lambdaN [expr $nEigenJ-1]]'])
        outputLogger.add_array(['set lambda1 [expr pow($lambdaI,0.5)]'])
        outputLogger.add_array(['set lambda2 [expr pow($lambdaJ,0.5)]'])
        outputLogger.add_array(['set T1 [expr 2.0*3.14/$lambda1]'])
        outputLogger.add_array(['puts "T1 = $T1"'])
        outputLogger.add_array(
            ['set a0 [expr {}*2.0*$lambda1*$lambda2/($lambda1+$lambda2)]'.format(xi)]
        )
        outputLogger.add_array(
            ['set a1 [expr {}*2.0/($lambda1+$lambda2)]'.format(xi)]
        )
        outputLogger.add_array(['rayleigh $a0 0.0 $a1 0.0'])

        if preparePushover == False:
            return

        if not os.path.exists('Pushover'):
            os.mkdir('Pushover')

        # Recording of forces and deformations from nonlinear analysis
        op.recorder(
            'Element',
            '-file',
            'Pushover/beams_force_1.out',
            '-time',
            '-ele',
            *list_beams,
            'section',
            1,
            'force',
        )
        op.recorder(
            'Element',
            '-file',
            'Pushover/beams_def_1.out',
            '-time',
            '-ele',
            *list_beams,
            'section',
            1,
            'deformation',
        )
        op.recorder(
            'Element',
            '-file',
            'Pushover/beams_force_6.out',
            '-time',
            '-ele',
            *list_beams,
            'section',
            6,
            'force',
        )
        op.recorder(
            'Element',
            '-file',
            'Pushover/beams_def_6.out',
            '-time',
            '-ele',
            *list_beams,
            'section',
            6,
            'deformation',
        )
        op.recorder(
            'Element',
            '-file',
            'Pushover/cols_force_1.out',
            '-time',
            '-ele',
            *list_cols,
            'section',
            1,
            'force',
        )
        op.recorder(
            'Element',
            '-file',
            'Pushover/cols_def_1.out',
            '-time',
            '-ele',
            *list_cols,
            'section',
            1,
            'deformation',
        )
        op.recorder(
            'Element',
            '-file',
            'Pushover/cols_force_6.out',
            '-time',
            '-ele',
            *list_cols,
            'section',
            6,
            'force',
        )
        op.recorder(
            'Element',
            '-file',
            'Pushover/cols_def_6.out',
            '-time',
            '-ele',
            *list_cols,
            'section',
            6,
            'deformation',
        )
        op.recorder(
            'Node',
            '-file',
            'Pushover/HoriNodes.out',
            '-time',
            '-node',
            *ListNodes,
            '-dof',
            1,
            'disp',
        )
        op.recorder(
            'Node',
            '-file',
            'Pushover/VertNodes.out',
            '-time',
            '-node',
            *ListNodes,
            '-dof',
            2,
            'disp',
        )

        # Create a Plain load pattern for gravity loading with a Linear TimeSeries
        op.timeSeries('Linear', 1)
        op.pattern('Plain', 1, 1)
        for Ele in EleCol:
            op.eleLoad(
                '-ele', Ele.EleTag, '-type', '-beamUniform', 0, -Ele.AEle * GConc
            )
        for Ele in EleBeam:
            op.eleLoad(
                '-ele', Ele.EleTag, '-type', '-beamUniform', -Ele.AEle * GConc - WDL
            )

        Tol = 1.0e-6  # convergence tolerance for test
        op.constraints('Plain')  # how it handles boundary conditions
        op.numberer(
            'Plain'
        )  # renumber dof to minimize band-width (optimization), if you want to
        op.system(
            'BandGeneral'
        )  # how to store and solve the system of equations in the analysis
        op.test(
            'NormDispIncr', Tol, 100
        )  # determine if convergence has been achieved at the end of an iteration step
        op.algorithm(
            'KrylovNewton'
        )  # use Newton solution algorithm: updates tangent stiffness at every iteration
        NstepGravity = 10  # apply gravity in 10 steps
        DGravity = 1.0 / NstepGravity  # first load increment;
        op.integrator(
            'LoadControl', DGravity
        )  # determine the next time step for an analysis
        op.analysis('Static')  # define type of analysis static or transient
        op.analyze(NstepGravity)  # apply gravity
        op.loadConst('-time', 0.0)

        # xi = 0.05  # damping ratio
        MpropSwitch = 1.0
        KcurrSwitch = 0.0
        KcommSwitch = 1.0
        KinitSwitch = 0.0
        nEigenI = 1  # mode 1
        nEigenI2 = 2  # mode 2
        nEigenJ = 3  # mode 3
        lambdaN = op.eigen(nEigenJ)  # eigenvalue analysis for nEigenJ modes
        lambdaI = lambdaN[nEigenI - 1]  # eigenvalue mode i
        lambdaI2 = lambdaN[nEigenI2 - 1]  # eigenvalue mode i2
        lambdaJ = lambdaN[nEigenJ - 1]  # eigenvalue mode j
        print('lambdaN ', lambdaN)
        omegaI = pow(lambdaI, 0.5)
        omegaI2 = pow(lambdaI2, 0.5)
        omegaJ = pow(lambdaJ, 0.5)
        T1m = 2.0 * pi / omegaI
        T2m = 2.0 * pi / omegaI2

        print('Ta1=', T1m, 'seg', ' Ta2=', T2m, ' seg')
        alphaM = (
            MpropSwitch * xi * (2.0 * omegaI * omegaJ) / (omegaI + omegaJ)
        )  # M-prop. damping D = alphaM*M
        betaKcurr = (
            KcurrSwitch * 2.0 * xi / (omegaI + omegaJ)
        )  # current-K      +beatKcurr*KCurrent
        betaKcomm = (
            KcommSwitch * 2.0 * xi / (omegaI + omegaJ)
        )  # last-committed K   +betaKcomm*KlastCommitt
        betaKinit = (
            KinitSwitch * 2.0 * xi / (omegaI + omegaJ)
        )  # initial-K     +beatKinit*Kini
        op.rayleigh(alphaM, betaKcurr, betaKinit, betaKcomm)  # RAYLEIGH damping

    # Pushover function
    def Pushover(self, rootSIM):
        def __init__(rootSIM):
            self.rootSIM = rootSIM

        global cbar

        def singlePush1(dref, mu, ctrlNode, dispDir, nSteps):
            IOflag = 2
            testType = 'RelativeNormDispIncr'
            # set testType	EnergyIncr;					# Dont use with Penalty constraints
            # set testType	RelativeNormUnbalance;		# Dont use with Penalty constraints
            # set testType	RelativeNormDispIncr;		# Dont use with Lagrange constraints
            # set testType	RelativeTotalNormDispIncr;	# Dont use with Lagrange constraints
            # set testType	RelativeEnergyIncr;			# Dont use with Penalty constraints
            tolInit = 1.0e-6  # the initial Tolerance, so it can be referred back to
            iterInit = 50  # the initial Max Number of Iterations
            algorithmType = 'KrylovNewton'  # the algorithm type

            op.test(
                testType, tolInit, iterInit
            )  # determine if convergence has been achieved at the end of an iteration step
            op.algorithm(
                algorithmType
            )  # use Newton solution algorithm: updates tangent stiffness at every iteration
            disp = dref * mu
            dU = disp / (1.0 * nSteps)
            print('dref ', dref, 'mu ', mu, 'dU ', dU, 'disp ', disp)
            op.integrator(
                'DisplacementControl', ctrlNode, dispDir, dU
            )  # determine the next time step for an analysis
            op.analysis('Static')  # define type of analysis static or transient

            # Print values
            if IOflag >= 1:
                print('singlePush: Push ', ctrlNode, ' to ', mu)

            #      the initial values to start the while loop
            ok = 0
            step = 1
            loadf = 1.0
            # This feature of disabling the possibility of having a negative loading has been included.
            # This has been adapted from a similar script by Prof. Garbaggio
            htot = op.nodeCoord(ctrlNode, 2)
            maxDriftPiso = 0.0
            VBasal_v = []
            DriftTecho_v = []
            while step <= nSteps and ok == 0 and loadf > 0:
                # self.ui.progressBar.setValue(100 * step / nSteps)
                ok = op.analyze(1)
                loadf = op.getTime()
                temp = op.nodeDisp(ctrlNode, dispDir)
                # Print the current displacement
                if IOflag >= 2:
                    print(
                        'Pushed ',
                        ctrlNode,
                        ' in ',
                        dispDir,
                        ' to ',
                        temp,
                        ' with ',
                        loadf,
                        'step',
                        step,
                    )

                # If the analysis fails, try the following changes to achieve convergence
                # Analysis will be slower in here though...
                if ok != 0:
                    print('Trying relaxed convergence..')
                    op.test(
                        testType, tolInit * 0.01, iterInit * 50
                    )  # determine if convergence has been achieved at the end of an iteration step
                    ok = op.analyze(1)
                    op.test(
                        testType, tolInit, iterInit
                    )  # determine if convergence has been achieved at the end of an iteration step
                if ok != 0:
                    print('Trying Newton with initial then current .')
                    op.test(
                        testType, tolInit * 0.01, iterInit * 50
                    )  # determine if convergence has been achieved at the end of an iteration step
                    op.algorithm('Newton', '-initialThenCurrent')
                    ok = op.analyze(1)
                    op.algorithm(algorithmType)
                    op.test(
                        testType, tolInit, iterInit
                    )  # determine if convergence has been achieved at the end of an iteration step
                if ok != 0:
                    print('Trying ModifiedNewton with initial ..')
                    op.test(
                        testType, tolInit * 0.01, iterInit * 50
                    )  # determine if convergence has been achieved at the end of an iteration step
                    op.algorithm('ModifiedNewton', '-initial')
                    ok = op.analyze(1)
                    op.algorithm(algorithmType)
                    op.test(
                        testType, tolInit, iterInit
                    )  # determine if convergence has been achieved at the end of an iteration step
                if ok != 0:
                    print('Trying KrylovNewton ..')
                    op.test(
                        testType, tolInit * 0.01, iterInit * 50
                    )  # determine if convergence has been achieved at the end of an iteration step
                    op.algorithm('KrylovNewton')
                    ok = op.analyze(1)
                    op.algorithm(algorithmType)
                    op.test(
                        testType, tolInit, iterInit
                    )  # determine if convergence has been achieved at the end of an iteration step
                if ok != 0:
                    print('Perform a Hail Mary ....')
                    op.test(
                        'FixedNumIter', iterInit
                    )  # determine if convergence has been achieved at the end of an iteration step
                    ok = op.analyze(1)

                for nod_ini, nod_end in zip(
                    ListNodesDrift[:-1, 0], ListNodesDrift[1:, 0]
                ):
                    # print('nod_ini ', nod_ini, 'nod_end', nod_end)
                    nod_ini = int(nod_ini)
                    nod_end = int(nod_end)
                    pos_i = op.nodeCoord(nod_ini, 2)
                    pos_s = op.nodeCoord(nod_end, 2)
                    hpiso = pos_s - pos_i
                    desp_i = op.nodeDisp(nod_ini, 1)
                    desp_s = op.nodeDisp(nod_end, 1)
                    desp_piso = abs(desp_s - desp_i)
                    drift_piso = desp_piso / hpiso
                    if drift_piso >= maxDriftPiso:
                        maxDriftPiso = drift_piso

                VBasal = 0.0
                op.reactions()
                for node in ListNodesBasal:
                    # print('ind Basal ', node[0])
                    VBasal = VBasal + op.nodeReaction(node[0], 1)
                VBasal_v = np.append(VBasal_v, VBasal)
                DriftTecho = op.nodeDisp(ctrlNode, dispDir) / htot
                DriftTecho_v = np.append(DriftTecho_v, DriftTecho)
                loadf = op.getTime()
                step += 1
            maxDriftTecho = dU * step / htot
            maxDriftTecho2 = op.nodeDisp(ctrlNode, dispDir) / htot

            if ok != 0:
                print('DispControl Analysis FAILED')
            else:
                print('DispControl Analysis SUCCESSFUL')
            if loadf <= 0:
                print('Stopped because of Load factor below zero: ', loadf)
            #    if PrintFlag == 0:
            #        os.remove("singlePush.txt")
            #        print singlePush.txt
            return (
                maxDriftPiso,
                maxDriftTecho,
                maxDriftTecho2,
                VBasal_v,
                DriftTecho_v,
            )

        # Pushover function varying tests and algorithms
        def singlePush(dref, mu, ctrlNode, dispDir, nSteps):
            # --------------------------------------------------
            # Description of Parameters
            # --------------------------------------------------
            # dref:			Reference displacement to which cycles are run. Corresponds to yield or equivalent other, such as 1mm
            # mu:			Multiple of dref to which the push is run. So pushover can be run to a specifived ductility or displacement
            # ctrlNode:		Node to control with the displacement integrator.
            # dispDir:		DOF the loading is applied.
            # nSteps:		Number of steps.
            # IOflag:		Option to print details on screen. 2 for print of each step, 1 for basic info (default), 0 for off
            # ---------------------------------------------------
            test = {
                1: 'NormDispIncr',
                2: 'RelativeEnergyIncr',
                3: 'EnergyIncr',
                4: 'RelativeNormUnbalance',
                5: 'RelativeNormDispIncr',
                6: 'NormUnbalance',
                7: 'FixedNumIter',
            }
            alg = {
                1: 'KrylovNewton',
                2: 'SecantNewton',
                3: 'ModifiedNewton',
                4: 'RaphsonNewton',
                5: 'PeriodicNewton',
                6: 'BFGS',
                7: 'Broyden',
                8: 'NewtonLineSearch',
            }

            # test = {1:'NormDispIncr', 2: 'RelativeEnergyIncr', 3:'EnergyIncr'}
            # alg = {1:'KrylovNewton', 2:'ModifiedNewton'}

            IOflag = 2
            PrintFlag = 0
            testType = 'RelativeNormDispIncr'  # Dont use with Penalty constraints

            tolInit = 1.0e-7  # the initial Tolerance, so it can be referred back to
            iterInit = 50  # the initial Max Number of Iterations
            algorithmType = 'KrylovNewton'  # the algorithm type
            #      	algorithmType Newton;		#      the algorithm type
            #      	algorithmType Newton;		#      the algorithm type

            # op.constraints('Transformation') # how it handles boundary conditions
            # op.numberer('RCM')    # renumber dof to minimize band-width (optimization), if you want to
            # op.system('BandGeneral') # how to store and solve the system of equations in the analysis

            op.test(
                testType, tolInit, iterInit
            )  # determine if convergence has been achieved at the end of an iteration step
            op.algorithm(
                algorithmType
            )  # use Newton solution algorithm: updates tangent stiffness at every iteration
            disp = dref * mu
            dU = disp / (1.0 * nSteps)
            print(
                'dref ', dref, 'mu ', mu, 'dU ', dU, 'disp ', disp, 'nSteps ', nSteps
            )
            op.integrator(
                'DisplacementControl', ctrlNode, dispDir, dU
            )  # determine the next time step for an analysis
            op.analysis('Static')  # defivne type of analysis static or transient

            # Print values
            if IOflag >= 1:
                print('singlePush: Push ', ctrlNode, ' to ', mu)

            #      the initial values to start the while loop
            ok = 0
            step = 1
            loadf = 1.0
            # This feature of disabling the possibility of having a negative loading has been included.
            # This has been adapted from a similar script by Prof. Garbaggio
            maxDriftPiso = 0.0
            htot = op.nodeCoord(ctrlNode, 2)
            VBasal_v = []
            DriftTecho_v = []
            # factor_v = np.array([1,0.75,0.5,0.25,0.1,2,3,5,10])
            # fact_v = np.array([50,100,500])
            # factor = 100
            # fact = 1.
            while step <= nSteps and ok == 0 and loadf > 0:
                # self.ui.progressBar.setValue(100 * step / nSteps)
                ok = op.analyze(1)
                loadf = op.getTime()
                temp = op.nodeDisp(ctrlNode, dispDir)
                if IOflag >= 2:
                    print(
                        'Pushed ',
                        ctrlNode,
                        ' in ',
                        dispDir,
                        ' to ',
                        temp,
                        ' with ',
                        loadf,
                        'step ',
                        step,
                    )
                # for factor in factor_v:
                # op.integrator('DisplacementControl',ctrlNode,dispDir,factor*dU)  # determine the next time step for an analysis
                # for fact in fact_v:
                for j in alg:
                    for i in test:
                        for fact in [1, 20, 50]:
                            if ok != 0 and j >= 4 and i != 7:
                                # print('Trying ',str(alg[j]))
                                op.test(test[i], tolInit * 0.01, iterInit * fact)
                                op.algorithm(alg[j])
                                ok = op.analyze(1)
                                op.algorithm(algorithmType)
                                op.test(testType, tolInit, iterInit)
                            elif ok != 0 and j < 4 and i != 7:
                                # print('Trying ',str(alg[j]))
                                op.test(test[i], tolInit, iterInit * fact)
                                op.algorithm(alg[j], '-initial')
                                ok = op.analyze(1)
                                op.algorithm(algorithmType)
                                op.test(testType, tolInit, iterInit)
                            if ok == 0:
                                break
                        if ok != 0 and i == 7:
                            op.test(test[i], iterInit)
                            op.algorithm(alg[j])
                            ok = op.analyze(1)
                        if ok == 0:
                            break
                    if ok == 0:
                        break
                    # if ok == 0:
                    #     break
                    # if ok == 0:
                    #     break
                # op.integrator('DisplacementControl',ctrlNode,dispDir,dU)  # determine the next time step for an analysis
                # Calculation of maximum Drift between floors
                for nod_ini, nod_end in zip(
                    ListNodesDrift[:-1, 0], ListNodesDrift[1:, 0]
                ):
                    # print('nod_ini ', nod_ini, 'nod_end', nod_end)
                    nod_ini = int(nod_ini)
                    nod_end = int(nod_end)
                    pos_i = op.nodeCoord(nod_ini, 2)
                    pos_s = op.nodeCoord(nod_end, 2)
                    hpiso = pos_s - pos_i
                    desp_i = op.nodeDisp(nod_ini, 1)
                    desp_s = op.nodeDisp(nod_end, 1)
                    desp_piso = abs(desp_s - desp_i)
                    drift_piso = desp_piso / hpiso
                    if drift_piso >= maxDriftPiso:
                        maxDriftPiso = drift_piso

                VBasal = 0.0
                op.reactions()
                for node in ListNodesBasal:
                    # print('ind Basal ', node[0])
                    VBasal = VBasal + op.nodeReaction(node[0], 1)
                VBasal_v = np.append(VBasal_v, VBasal)
                DriftTecho = op.nodeDisp(ctrlNode, dispDir) / htot
                DriftTecho_v = np.append(DriftTecho_v, DriftTecho)
                loadf = op.getTime()
                step += 1
            maxDriftTecho = dU * step / htot
            maxDriftTecho2 = op.nodeDisp(ctrlNode, dispDir) / htot

            if ok != 0:
                print('DispControl Analysis FAILED')
            else:
                print('DispControl Analysis SUCCESSFUL')
            if loadf <= 0:
                print('Stopped because of Load factor below zero: ', loadf)
            #    if PrintFlag == 0:
            #        os.remove("singlePush.txt")
            #        print singlePush.txt
            return (
                maxDriftPiso,
                maxDriftTecho,
                maxDriftTecho2,
                VBasal_v,
                DriftTecho_v,
            )

        ListNodesDrift = ListNodes[np.where(ListNodes[:, 1] == 0.0)]
        ListNodesBasal = ListNodes[np.where(ListNodes[:, 2] == 0.0)]
        if T1m <= 0.5:
            k = 1.0
        elif T1m <= 2.5:
            k = 0.75 + 0.5 * T1m
        else:
            k = 2.0

        sumH = np.sum(np.power(Loc_heigth, k))
        floors_num = len(Loc_heigth)

        # Match default example
        triangForceDist = True

        # Defining the pushover lateral distribution type
        if triangForceDist == True:
            Fp = np.power(Loc_heigth, k) / sumH
        else:
            Fp = 1.0 / floors_num * np.ones(floors_num + 1)
        print('Fp =', Fp)
        op.loadConst('-time', 0.0)
        op.timeSeries('Linear', 2)
        op.pattern('Plain', 2, 1)
        for node, fp, ind in zip(ListNodesDrift, Fp, range(floors_num)):
            op.load(int(node[0]), fp, 0.0, 0.0)

        Htotal = Loc_heigth[-1]
        #        Der_obj = float(self.ui.Der_obj.text())
        Der_obj = 0.04  # Match default example
        Des_obj = Der_obj * Htotal  # Desplazamiento objetivo
        #        nSteps = int(self.ui.nSteps.text())
        nSteps = 110  # Match default example
        dref = Des_obj / nSteps
        mu = nSteps
        IDctrlNode = int(ListNodesDrift[-1, 0])  # Node where displacement is read
        print('IDctrlNode =', IDctrlNode)
        IDctrlDOF = 1  # DOF x=1, y=2
        Tol = 1.0e-4  # Tolerance

        runFastPushover = True
        if runFastPushover == True:
            maxDriftPiso, maxDriftTecho, maxDriftTecho2, VBasal_v, DriftTecho_v = (
                singlePush1(dref, mu, IDctrlNode, IDctrlDOF, nSteps)
            )
        else:
            maxDriftPiso, maxDriftTecho, maxDriftTecho2, VBasal_v, DriftTecho_v = (
                singlePush(dref, mu, IDctrlNode, IDctrlDOF, nSteps)
            )

        op.wipe()

        # Reading of forces and deflections of beams and columns from recorders
        beams_force_1 = np.loadtxt('Pushover/beams_force_1.out')
        beams_def_1 = np.loadtxt('Pushover/beams_def_1.out')
        beams_force_6 = np.loadtxt('Pushover/beams_force_6.out')
        beams_def_6 = np.loadtxt('Pushover/beams_def_6.out')
        cols_force_1 = np.loadtxt('Pushover/cols_force_1.out')
        cols_def_1 = np.loadtxt('Pushover/cols_def_1.out')
        cols_force_6 = np.loadtxt('Pushover/cols_force_6.out')
        cols_def_6 = np.loadtxt('Pushover/cols_def_6.out')
        print('cols_def_1', cols_def_1)

        # fy = float(self.ui.fy.text()) * MPa
        fy = float(rootSIM['FySteel']) * MPa
        print('Fy', fy)

        Es = 200.0 * GPa
        ey = fy / Es
        num_beams = len(EleBeam)
        num_cols = len(EleCol)
        CD_Beams = np.zeros([num_beams, 2])

        # Calculation of curvature ductility of beams and columns
        for ind, DB in zip(range(1, num_beams + 1), DataBeamDesing):
            ets_beam_1 = beams_def_1[:, 2 * ind - 1] + beams_def_1[:, 2 * ind] * (
                DB.dt1 - DB.h / 2
            )
            ebs_beam_1 = beams_def_1[:, 2 * ind - 1] + beams_def_1[:, 2 * ind] * (
                DB.h / 2 - DB.db1
            )
            ets_beam_6 = beams_def_6[:, 2 * ind - 1] + beams_def_6[:, 2 * ind] * (
                DB.dt2 - DB.h / 2
            )
            ebs_beam_6 = beams_def_6[:, 2 * ind - 1] + beams_def_6[:, 2 * ind] * (
                DB.h / 2 - DB.db1
            )
            es_beam_1 = np.maximum(np.absolute(ets_beam_1), np.absolute(ebs_beam_1))
            es_beam_6 = np.maximum(np.absolute(ets_beam_6), np.absolute(ebs_beam_6))
            print('es_beam_1', es_beam_1, 'es_beam_6', es_beam_6)
            if np.max(es_beam_1) <= ey:
                CD_1 = 0
            else:
                fi_1 = np.absolute(beams_def_1[:, 2 * ind])
                M_beam_1 = np.absolute(beams_force_1[:, 2 * ind])
                f = interpolate.interp1d(es_beam_1, M_beam_1)
                My_1 = f(ey)
                f = interpolate.interp1d(M_beam_1, fi_1)
                fiy_1 = f(My_1)
                CD_1 = fi_1[-1] / fiy_1
            if np.max(es_beam_6) <= ey:
                CD_6 = 0
            else:
                fi_6 = np.absolute(beams_def_6[:, 2 * ind])
                M_beam_6 = np.absolute(beams_force_6[:, 2 * ind])
                f = interpolate.interp1d(es_beam_6, M_beam_6)
                My_6 = f(ey)
                f = interpolate.interp1d(M_beam_6, fi_6)
                fiy_6 = f(My_6)
                CD_6 = fi_6[-1] / fiy_6
            CD_Beams[ind - 1, :] = [CD_1, CD_6]
            print('CD_Beams =', CD_Beams)

        CD_Cols = np.zeros([num_cols, 2])
        for ind, DC in zip(range(1, num_cols + 1), DataColDesing):
            ets_col_1 = cols_def_1[:, 2 * ind - 1] + cols_def_1[:, 2 * ind] * (
                DC.d - DC.h / 2
            )
            ebs_col_1 = cols_def_1[:, 2 * ind - 1] + cols_def_1[:, 2 * ind] * (
                DC.h / 2 - DC.d
            )
            ets_col_6 = cols_def_6[:, 2 * ind - 1] + cols_def_6[:, 2 * ind] * (
                DC.d - DC.h / 2
            )
            ebs_col_6 = cols_def_6[:, 2 * ind - 1] + cols_def_6[:, 2 * ind] * (
                DC.h / 2 - DC.d
            )
            es_col_1 = np.maximum(np.absolute(ets_col_1), np.absolute(ebs_col_1))
            es_col_6 = np.maximum(np.absolute(ets_col_6), np.absolute(ebs_col_6))
            print('es_col_1', es_col_1, 'es_col_6', es_col_6)
            if np.max(es_col_1) <= ey:
                CD_1 = 0
            else:
                fi_1 = np.absolute(cols_def_1[:, 2 * ind])
                M_col_1 = np.absolute(cols_force_1[:, 2 * ind])
                f = interpolate.interp1d(es_col_1, M_col_1)
                Mfy_1 = f(ey)
                f = interpolate.interp1d(M_col_1, fi_1)
                fify_1 = f(Mfy_1)
                My_1 = np.max(M_col_1)
                fiy_1 = My_1 / Mfy_1 * fify_1
                CD_1 = fi_1[-1] / fiy_1

            if np.max(es_col_6) <= ey:
                CD_6 = 0
            else:
                fi_6 = np.absolute(cols_def_6[:, 2 * ind])
                M_col_6 = np.absolute(cols_force_6[:, 2 * ind])
                f = interpolate.interp1d(es_col_6, M_col_6)
                Mfy_6 = f(ey)
                f = interpolate.interp1d(M_col_6, fi_6)
                fify_6 = f(Mfy_6)
                My_6 = np.max(M_col_6)
                fiy_6 = My_6 / Mfy_6 * fify_6
                CD_6 = fi_6[-1] / fiy_6
            CD_Cols[ind - 1, :] = [CD_1, CD_6]
            print('CD_Cols =', CD_Cols)
        CD_Ele = np.concatenate((CD_Cols, CD_Beams), axis=0)

        Desp_x = np.loadtxt('Pushover/HoriNodes.out')
        Desp_y = np.loadtxt('Pushover/VertNodes.out')
        Nodes_desp_x = ListNodes[:, 1] + 3 * Desp_x[-1, 1:]
        Nodes_desp_y = ListNodes[:, 2] + 3 * Desp_y[-1, 1:]

        fpos = 0.1
        fsize = 1
        DataDC = []
        for Ele in Elements:
            xi = Nodes_desp_x[Ele.Nod_ini]
            yi = Nodes_desp_y[Ele.Nod_ini]
            xe = Nodes_desp_x[Ele.Nod_end]
            ye = Nodes_desp_y[Ele.Nod_end]
            x = np.array([xi, xe])
            y = np.array([yi, ye])
            Delta_x = xe - xi
            Delta_y = ye - yi
            xi_CD = xi + fpos * Delta_x
            yi_CD = yi + fpos * Delta_y
            xe_CD = xe - fpos * Delta_x
            ye_CD = ye - fpos * Delta_y
            CD_i = CD_Ele[Ele.EleTag - 1, 0]
            CD_e = CD_Ele[Ele.EleTag - 1, 1]
            DataDC.append(
                DuctilityCurve(
                    xi_CD, xe_CD, yi_CD, ye_CD, fsize * CD_i, fsize * CD_e
                )
            )
        DC_x, DC_y, DC_size = [], [], []
        for DC in DataDC:
            DC_x.append([DC.xi, DC.xe])
            DC_y.append([DC.yi, DC.ye])
            DC_size.append([DC.CD_i, DC.CD_e])
        DC_x = np.array(DC_x)
        DC_x = DC_x.flatten()
        DC_y = np.array(DC_y)
        DC_y = DC_y.flatten()
        DC_size = np.array(DC_size)
        DC_size = DC_size.flatten()
        print('DC_x= ', DC_x)
        print('DC_y= ', DC_y)
        print('DC_size= ', DC_size)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--filenameAIM')
    parser.add_argument('--filenameEVENT')
    parser.add_argument('--filenameSAM')
    parser.add_argument('--getRV', nargs='?', const=True, default=False)
    args = parser.parse_args()

    sys.exit(
        runBuildingDesign(
            args.filenameAIM, args.filenameEVENT, args.filenameSAM, args.getRV
        )
    )
