## ############################################################### ##
## RC_FIAP (Reinforced Concrete Frame Inelastic Analysis Platform) ##
##                                                                 ##
## Developed by:                                                   ##
##       Victor F. Ceballos (vceballos@uninorte.edu.co)            ##
##       Carlos A. Arteta (carteta@uninorte.edu.co                 ##
## RC_FIAP_main.py : this is the main script that calls            ##
## GUIFrameNonLinearACI.py : graphical environment                 ##
## mplwidget.py : cript to help plot the plastic hinge projector   ##
## ############################################################### ##

# Modified by Dr. Stevan Gavrilovic @ SimCenter, UC Berkeley

import sys, os
import argparse, json

from math import pi, sqrt, ceil, floor
from scipy import interpolate

import openseespy.opensees as op
import numpy as np  # load the numpy module, calling it np

import pandas as pd
import os
from mpl_toolkits.axes_grid1 import make_axes_locatable

# Definition of units
m = 1.  # define basic units -- output units
kN = 1.  # define basic units -- output units
sec = 1.  # define basic units -- output units
mm = m / 1000.  # define engineering units
cm = m / 100.
N = kN / 1000.
MPa = N / mm ** 2
GPa = MPa * 1000
m2 = m ** 2  # m^2
m3 = m ** 3  # m^3
m4 = m ** 4  # m^4
inch = cm * 2.54
ft = 12. * inch
g = 9.81 * m / sec ** 2  # gravitational acceleration
kip = 4.448 * kN
ksi = kip / inch ** 2
psi = ksi / 1000.
lbf = psi * inch ** 2  # pounds force
pcf = lbf / ft ** 3  # pounds per cubic foot
psf = lbf / ft ** 3  # pounds per square foot
in2 = inch ** 2  # inch^2
in4 = inch ** 4  # inch^4
GConc = 24. * kN / m ** 3  # Specific gravity of concrete
cbar = False
np.set_printoptions(precision=6)


class BeamElasticElement:
    def __init__(self, EleTag, Nod_ini, Nod_end, AEle, EcEle, IzEle, LEle, BEle, HEle, ElegTr, RZi, RZe):
        self.EleTag = EleTag
        self.Nod_ini = Nod_ini
        self.Nod_end = Nod_end
        self.AEle = AEle
        self.EcEle = EcEle
        self.IzEle = IzEle
        self.LEle = LEle
        self.BEle = BEle
        self.HEle = HEle
        self.ElegTr = ElegTr
        self.RZi = RZi
        self.RZe = RZe

class BeamDesing:
    def __init__(self, EleTag, b, h, Ast1, dt1, Mn_n1, Asb1, db1, Mn_p1, ns1, ss1, Ast2, dt2, Mn_n2, Asb2, db2, Mn_p2,
                 ns2, ss2, Nod_ini, Nod_end, db_t1, db_b1, db_t2, db_b2):
        self.EleTag = EleTag
        self.b = b
        self.h = h
        self.Ast1 = Ast1
        self.dt1 = dt1
        self.Mn_n1 = Mn_n1
        self.Asb1 = Asb1
        self.db1 = db1
        self.Mn_p1 = Mn_p1
        self.ns1 = ns1
        self.ss1 = ss1
        self.Ast2 = Ast2
        self.dt2 = dt2
        self.Mn_n2 = Mn_n2
        self.Asb2 = Asb2
        self.db2 = db2
        self.Mn_p2 = Mn_p2
        self.ns2 = ns2
        self.ss2 = ss2
        self.Nod_ini = Nod_ini
        self.Nod_end = Nod_end
        self.db_t1 = db_t1
        self.db_b1 = db_b1
        self.db_t2 = db_t2
        self.db_b2 = db_b2


class ColDesing:
    def __init__(self, EleTag, b, h, nbH, nbB, db, As, Pu_v, Mu_v, fiPn, fiMn, Mn_i, d, dist, ro, Mu_i,
                 sst, nsB, nsH, Nod_ini, Nod_end):
        self.EleTag = EleTag
        self.b = b
        self.h = h
        self.nbH = nbH
        self.nbB = nbB
        self.db = db
        self.As = As
        self.Pu_v = Pu_v
        self.Mu_v = Mu_v
        self.fiPn = fiPn
        self.fiMn = fiMn
        self.Mn_i = Mn_i
        self.d = d
        self.dist = dist
        self.ro = ro
        self.Mu_i = Mu_i
        self.sst = sst
        self.nsB = nsB
        self.nsH = nsH
        self.Nod_ini = Nod_ini
        self.Nod_end = Nod_end


class DuctilityCurve:
    def __init__(self, xi, xe, yi, ye, CD_i, CD_e):
        self.xi = xi
        self.xe = xe
        self.yi = yi
        self.ye = ye
        self.CD_i = CD_i
        self.CD_e = CD_e
        

class TclLogger:
    def __init__(self):
        self.list_of_lines = ['# This is an autogenerated .tcl file from SimCenter workflow']
    
    # Add a string line to the output file
    def add_line(self, line, addNewLine = True):
        if addNewLine == True:
            self.list_of_lines.append(line+'\n')
        else :
            self.list_of_lines.append(line)
            
    # Convenience function to create a line from an array of inputs to openseespy function
    def add_array(self, line, addNewLine = True):
        
        outLine = ''
        for item in line:
            outLine += str(item) + ' '
        
#        # Remove the last space
#        outLine = outLine.rstrip()
#
#        # Add the ; char to the end of the line
#        outLine += ';'
        self.add_line(outLine,addNewLine)
    
    # Save the output file
    def save_as_file(self):
        
        # Get the current directory
        workingDirectory = os.getcwd()
        
        pathFile = os.path.join(workingDirectory, 'Model.tcl')
        
        if os.path.exists(pathFile):
            os.remove(pathFile)
        
        with open(pathFile, "a+") as file_object:
            
            appendEOL = False
            # Move read cursor to the start of file.
            file_object.seek(0)
            
            # Check if file is not empty
            data = file_object.read(100)
        
            if len(data) > 0:
                appendEOL = True
        
            # Iterate over each string in the list
            for line in self.list_of_lines:
                # If file is not empty then append '\n' before first line for
                # other lines always append '\n' before appending line
                if appendEOL == True:
                    file_object.write("\n")
                else:
                    appendEOL = True
                # Append element at the end of file
                file_object.write(line)
        
        # print(self.list_of_lines)


def runBuildingDesign(BIM_file, EVENT_file, SAM_file, getRV):
    
    # Get the current directory
    workingDirectory = os.getcwd()

    rootSIM = {}

    # Try to open the BIM json
    with open(BIM_file, 'r') as f:
        rootBIM = json.load(f)
    try:
        rootSIM = rootBIM['StructuralInformation']
    except:
        raise ValueError("RC_FIAP - structural information missing")


    # Get the random variables from the input file
    try:
        rootRV = rootBIM['randomVariables']
    except:
        raise ValueError("RC_FIAP - randomVariables section missing")
        
    RV_ARRAY = {}

    # Populate the RV array with name/value pairs.
    # If a random variable is used here, the RV array will contain its current value
    for rv in rootRV:
        # Try to get the name and value of the random variable
        rvName = rv['name']
        curVal = rv['value']

        # Check if the current value a realization of a RV, i.e., is not a RV label
        # If so, then set the current value as the mean
        if "RV" in str(curVal) :
            curVal = float(rv['mean'])

        RV_ARRAY[rvName] = curVal

    
    # *********************** Design Starts Here *************************
    #if getRV == "False":
    if getRV is False:
    
        print("Running seismic design in FIAP")

        # Create the tcl output logger
        outputLogger = TclLogger()
        
        outputLogger.add_line('# Reinforced Concrete Frame Inelastic Analysis Platform (RCFIAP)',False)
        outputLogger.add_line('# Developed by Victor Ceballos & Carlos Arteta',False)
        outputLogger.add_line('# Modified by Stevan Gavrilovic - NHERI SimCenter for use in EE-UQ')
        
        # Create a class object
        RCDes = RCFIAP()
        
        print("Starting seismic design")
        
        # Run the building design
        RCDes.Design(rootSIM)
        
        print("Creating nonlinear model")

        # Run a pushover analysis - for testing to compare with original code
        doPushover = False

        # Create the nonlinear model
        RCDes.CreateNLM(rootSIM,outputLogger,doPushover)
        
        # Save the output file from the logger
        outputLogger.save_as_file()

        if doPushover == True:
            print("Running pushover analysis")
            RCDes.Pushover(rootSIM)
            

    # Now create the SAM file for export
    root_SAM = {}

    root_SAM['mainScript'] = 'Model.tcl'
    root_SAM['type'] = 'OpenSeesInput'

    # Number of dimensions
    root_SAM['ndm'] = 2

    # Number of degrees of freedom at each node
    root_SAM['ndf'] = 3
    
    # The number of stories
    vecHeights = rootSIM["VecStoryHeights"]
    vecHeights = vecHeights.split(',')
    vecHeights = np.array(vecHeights, dtype=float)
    
    numStories = len(vecHeights)
    root_SAM['numStory'] = numStories
    
    # The number of spans
    vecSpans = rootSIM["VecSpans"]
    vecSpans = vecSpans.split(',')
    vecSpans = np.array(vecSpans, dtype=float)
    numSpans = len(vecSpans)
   
    # Get the node mapping
    # Consider a structure with 3 stories and 2 spans
    # Then the node numbering scheme is
    #   #9——————#10———————#11
    #   |        |        |
    #   |        |        |
    #   #6——————#7———————#8
    #   |        |        |
    #   |        |        |
    #   #3——————#4———————#5
    #   |        |        |
    #   |        |        |
    #   #0       #1      #2

    clineOffset = 0
    if numSpans > 1:
        clineOffset = int(numSpans/2)
    
    node_map = []
    
    # Using nodes on column #1 to calculate story drift
    for i in range(0, numStories+1):

        nodeTag = i*(numSpans+1)

        # Create the node and add it to the node mapping array
        node_entry = {}
        node_entry['node'] = nodeTag
        node_entry['cline'] = 'response'
        node_entry['floor'] = '{}'.format(i)
        node_map.append(node_entry)

        ## KZ & AZ: Add centroid for roof drift
        node_entry_c = {}
        node_entry_c['node'] = nodeTag + clineOffset
        node_entry_c['cline'] = 'centroid'
        node_entry_c['floor'] = '{}'.format(i)
        node_map.append(node_entry_c)

    root_SAM['NodeMapping'] = node_map

    with open(SAM_file, 'w') as f:
        json.dump(root_SAM, f, indent=2)

# Main functionality
class RCFIAP:
    def Design(self, rootSIM):
        def __init__(rootSIM):
            self.rootSIM = rootSIM
            
        global Loc_span, Loc_heigth, ListNodes, Elements, DataBeamDesing, DataColDesing, WDL, WLL, WDLS, Wtotal, cover

        # Function: Reads Beams design data from table that allows the user to modify the default design from TAB2 of GUI
        def data_beams_table(self):
            self.registros_beams = []

            for DB in DataBeamDesing:
                b = DB.b / cm
                h = DB.h / cm
                L_As_top = DB.Ast1 / cm ** 2
                L_As_bot = DB.Asb1 / cm ** 2
                R_As_top = DB.Ast2 / cm ** 2
                R_As_bot = DB.Asb2 / cm ** 2
                L_Leg_n = DB.ns1
                R_Leg_n = DB.ns2
                L_Sstirrup = DB.ss1 / cm
                R_Sstirrup = DB.ss2 / cm
                registro = RegistroBeams(DB.EleTag, b, h, L_As_top, L_As_bot, L_Leg_n, L_Sstirrup, R_As_top, R_As_bot, R_Leg_n, R_Sstirrup)
                self.registros_beams.append(registro)

        # Function: Reads Columns design data from table that allows the user to modify the default design from TAB2 of GUI.
        def data_columns_table(self):
            self.registros_cols = []
            
            for DC in DataColDesing:
                b = DC.b / cm
                h = DC.h / cm
                db = DC.db / mm
                nbH = DC.nbH
                nbB = DC.nbB
                nsH = DC.nsH
                nsB = DC.nsB
                sst = DC.sst / cm
                registro = RegistroColumns(DC.EleTag, b, h, db, nbH, nbB, nsH, nsB, sst)
                self.registros_cols.append(registro)

        # Compression block parameters beta as function f'c
        def beta1(fc):
            if fc <= 28 * MPa:
                Beta1 = 0.85
            else:
                Beta1 = max([0.85 - 0.05 * (fc - 28.) / 7., 0.65])
            return Beta1

        # Design load combinations
        def Combo_ACI(DL, LL, E):
            U1 = 1.2 * DL + 1.6 * LL
            U2 = 1.2 * DL + 1.0 * LL + 1.0 * E
            U3 = 1.2 * DL + 1.0 * LL - 1.0 * E
            U4 = 0.9 * DL + 1.0 * E
            U5 = 0.9 * DL - 1.0 * E
            return U1, U2, U3, U4, U5

        # Flexural beams design
        def AsBeam(Mu, EleTag):
            b, h = BBeam, HBeam
            Mu = abs(Mu)
            db_v = np.array([4, 5, 6, 7, 8, 10])
            for ndb in db_v:
                db = ndb / 8. * inch
                d = h - cover - dst - 0.5 * db
                if Mu == 0.0:
                    ro_req = ro_min_b
                else:
                    ro_req = 0.85 * fcB / fy * (1. - sqrt(1. - 2. * (Mu / 0.9 / b / d ** 2) / 0.85 / fcB))
                if ro_req < ro_min_b:
                    ro_req = ro_min_b
                As_req = ro_req * b * d
                Ab = pi * db ** 2 / 4.
                nb = max(2., ceil(As_req / Ab))
                As_con = nb * Ab
                slb = (b - 2 * cover - 2 * dst - nb * db) / (nb - 1.)  # free clear bars
                if slb >= max(1. * inch, db):
                    break
                if ro_req > ro_max_b:
                    print("Steel percentage greater than the maximum in Beam " + str(EleTag))
            if slb < min(1. * inch, db):
                print("Bar separation is not ok in Beam " + str(EleTag))
            a = fy * As_con / 0.85 / fcB / b
            Mn = fy * As_con * (d - a / 2.)
            return As_con, d, Mn, db

        # Shear beams design
        def AvBeam(Vu, db, d, EleTag):
            Vc = 0.17 * sqrt(fcB / 1000.) * MPa * BBeam * d
            Vs = (Vu - 0.75 * Vc) / 0.75
            if Vs > 4. * Vc:
                print("reshape by shear in Beam " + str(EleTag))
            se_1 = min(d / 4., 8. * db, 24. * dst, 300. * mm)
            nr_v = np.array([2, 3, 4])  # vector de numero de ramas
            if Vs <= 0.:
                se = se_1
                nra = 2.
            else:
                for nra in nr_v:
                    Ave = Ast * nra  # area transversal del estribo
                    se_2 = Ave * fy * d / Vs
                    se = min(se_1, se_2)
                    if se >= 60. * mm:
                        break
            se = floor(se / cm) * cm
            if se < 60. * mm:
                print("Stirrup spacing is less than 6 cm in beam " + str(EleTag))
            return nra, se

        # Colmuns P-M design
        def AsColumn():
            verif = False
            while verif == False:
                for ndb in db_v:
                    db = ndb / 8. * inch
                    Ab = pi * db ** 2. / 4.
                    dp = cover + dst + 0.5 * db
                    d = h - dp
                    for nbH in nbH_v:
                        for nbB in nbB_v:
                            nbT = 2. * (nbB + nbH - 2.)  # numero total de barras
                            Ast = nbT * Ab
                            ro = Ast / b / h
                            As = np.hstack([nbB * Ab, np.ones(nbH - 2) * 2 * Ab, nbB * Ab])
                            dist = np.linspace(dp, h - dp, nbH)
                            if ro >= ro_min:
                                Pn_max = 0.80 * (0.85 * fcC * (b * h - Ast) + fy * Ast)
                                Tn_max = -fy * Ast
                                c = np.linspace(1.1 * h / npts, 1.1 * h, npts)
                                a = Beta1C * c
                                Pconc = 0.85 * fcC * a * b
                                Mconc = Pconc * (h - a) / 2.
                                et = ecu * (d - c) / c
                                fiv = np.copy(et)
                                fiv = np.where(fiv >= 0.005, 0.9, fiv)
                                fiv = np.where(fiv <= 0.002, 0.65, fiv)
                                fiv = np.where((fiv > 0.002) & (fiv < 0.005), (0.65 + 0.25 * (fiv - 0.002) / 0.003),
                                               fiv)
                                c = c[:, np.newaxis]
                                es = ecu * (c - dist) / c
                                fs = Es * es
                                fs = np.where(fs > fy, fy, fs)
                                fs = np.where(fs < -fy, -fy, fs)
                                Pacer = np.sum(fs * As, axis=1)
                                Macer = np.sum(fs * As * (h / 2. - dist), axis=1)
                                Pn = np.hstack(
                                    [Tn_max, np.where(Pconc + Pacer > Pn_max, Pn_max, Pconc + Pacer), Pn_max])
                                Mn = np.hstack([0, Mconc + Macer, 0])
                                fiv = np.hstack([0.9, fiv, 0.65])
                                fiPn = fiv * Pn
                                fiMn = fiv * Mn
                                if np.all((Pu_v >= min(fiPn)) & (Pu_v <= max(fiPn))):
                                    Mu_i = np.interp(Pu_v, fiPn, fiMn)
                                    Mn_i = np.interp(Pu_v, Pn, Mn)
                                    if np.all(Mu_i >= Mu_v) == True:
                                        verif = True
                                        break
                        if verif == True:
                            break
                    if verif == True:
                        break
                if ndb == db_v[-1] and ro > ro_max:
                    print('column ' + str(EleTag) + 'needs to be resized by reinforcement ratio')
                    break
            return nbH, nbB, db, As, fiPn, fiMn, Mn_i, d, dist, ro, Mu_i

        # Shear columns design
        def AvColumn():
            fiv = 0.75
            Ag = b * h
            se_1 = min(8. * db, b / 2., h / 2., 200. * mm)  # separacion minima c.18.4.3.3 ACI-19
            dp = cover + dst + db / 2
            d = h - dp
            neH = floor(nbH / 2) + 1
            neB = floor(nbB / 2) + 1

            Ash_H = neH * Ast
            Ash_B = neB * Ast

            Vc = (0.17 * sqrt(fcC * MPa) + Nu_min / 6 / Ag) * b * d
            Vs = (Vu - fiv * Vc) / fiv
            if Vs <= 1 / 3 * sqrt(fcC * MPa) * b * d:
                se_1 = se_1
            elif Vs >= 1 / 3 * sqrt(fcC * MPa) * b * d:
                se_1 = min(se_1, h / 4)

            if Vs > 0.66 * sqrt(fcC * MPa) * b * d:
                print('Resize the column' + str(EleTag) + ' by shear ')

            if Vs <= 0.:
                se = se_1
            else:
                Ave = Ash_B  # area transversal del estribo
                se_2 = Ave * fy * d / Vs
                se = min([se_1, se_2])
            if se < 60. * mm:
                print('Minimum spacing of stirrups is not met in column ' + str(EleTag))
            return se, neB, neH

        # Input geometric, materials and seismic design parameters from TAB1 of GUI
        
        # Lafg = float(self.ui.Lafg.text())
        Lafg = float(rootSIM["TribLengthGravity"])
        
        # Lafs = float(self.ui.Lafs.text())
        Lafs = float(rootSIM["TribLengthSeismic"])

        # DL = float(self.ui.DL.text())
        DL = float(rootSIM["DeadLoad"])
        
        # LL = float(self.ui.LL.text())
        LL = float(rootSIM["LiveLoad"])
        
        # HColi = float(self.ui.HColi.text())  # Column inside Depth
        HColi = float(rootSIM["IntColDepth"])
        
        # BColi = float(self.ui.BColi.text())  # Column inside Width
        BColi = float(rootSIM["IntColWidth"])

        # HCole = float(self.ui.HCole.text())  # Column outside Depth
        HCole = float(rootSIM["ExtColDepth"])

        # BCole = float(self.ui.BCole.text())  # Column outside Width
        BCole = float(rootSIM["ExtColWidth"])

        # HBeam = float(self.ui.HBeam.text())
        HBeam = float(rootSIM["BeamDepth"])
        
        # BBeam = float(self.ui.BBeam.text())
        BBeam = float(rootSIM["BeamWidth"])

        # IFC = float(self.ui.InertiaColumnsFactor.text())
        IFC = float(rootSIM["ColIg"])
        
        # IFB = float(self.ui.InertiaBeamsFactor.text())
        IFB = float(rootSIM["BeamIg"])
                
        # heigth_v = self.ui.heigth_v.text()
        heigth_v = rootSIM["VecStoryHeights"]

        heigth_v = heigth_v.split(',')
        heigth_v = np.array(heigth_v, dtype=float)
        
        # span_v = self.ui.span_v.text()
        span_v = rootSIM["VecSpans"]

        span_v = span_v.split(',')
        span_v = np.array(span_v, dtype=float)
        
        # fy = float(self.ui.fy.text()) * MPa
        fy = float(rootSIM["FySteel"]) * MPa
        
        # fcB = float(self.ui.fcB.text()) * MPa
        fcB = float(rootSIM["BeamFpc"]) * MPa

        # fcC = float(self.ui.fcC.text()) * MPa
        fcC = float(rootSIM["ColFpc"]) * MPa

        # R = float(self.ui.R.text())
        R = float(rootSIM["RParam"])

        # Cd = float(self.ui.Cd.text())
        Cd = float(rootSIM["CdParam"])

        # Omo = float(self.ui.Omo.text())
        Omo = float(rootSIM["OmegaParam"])

        # Sds = float(self.ui.Sds.text())
        Sds = float(rootSIM["SDSParam"])

        # Sd1 = float(self.ui.Sd1.text())
        Sd1 = float(rootSIM["SD1Param"])

        # Tl = float(self.ui.Tl.text())
        Tl = float(rootSIM["TLParam"])

        WDL = Lafg * DL
        WDLS = Lafs * DL
        WLL = Lafg * LL
        
#        print("heigth_v: ")
#        print(heigth_v)
#        print("span_v: ")
#        print(span_v)
#        print("Lafg: "+str(Lafg))
#        print("Lafs: "+str(Lafs))
#        print("DL: "+str(DL))
#        print("LL: "+str(LL))
#        print("HColi: "+str(HColi))
#        print("BColi: "+str(BColi))
#        print("HCole: "+str(HCole))
#        print("BCole: "+str(BCole))
#        print("HBeam: "+str(HBeam))
#        print("BBeam: "+str(BBeam))
#        print("IFC: "+str(IFC))
#        print("IFB: "+str(IFB))
        print("********************fy: ",fy)
#        print("fcB: "+str(fcB))
#        print("fcC: "+str(fcC))
#        print("R: "+str(R))
#        print("Cd: "+str(Cd))
#        print("Omo: "+str(Omo))
#        print("Sds: "+str(Sds))
#        print("Sd1: "+str(Sd1))
#        print("Tl: "+str(Tl))

        # plt.close('all')
        op.wipe()
        op.model('Basic', '-ndm', 2, '-ndf', 3)

        # Nodes Creations
        Loc_span = np.append(0, np.cumsum(span_v))
        Loc_heigth = np.append(0, np.cumsum(heigth_v))
        n_col_axes = len(Loc_span)
        xn_v, yn_v = np.meshgrid(Loc_span, Loc_heigth)
        xn_vf = np.ravel(xn_v)
        yn_vf = np.ravel(yn_v)
        num_nodes = len(Loc_span) * len(Loc_heigth)
        ListNodes = np.empty([num_nodes, 3])
        nodeTag = 0
        for (xn, yn) in zip(xn_vf, yn_vf):
            ListNodes[nodeTag, :] = [nodeTag, xn, yn]
            op.node(nodeTag, xn, yn)
            if yn == 0.:
                op.fix(nodeTag, 1, 1, 1)
            nodeTag += 1
        for node in ListNodes:
            if node[2] > 0. and node[1] == 0.:
                MasterNode = node[0]
            if node[2] > 0. and node[1] != 0.:
                op.equalDOF(int(MasterNode), int(node[0]), 1)

        ListNodesDrift = ListNodes[np.where(ListNodes[:, 1] == 0.)]
        MassType = "-lMass"  # -lMass, -cMass

        # Columns creation for elastic analysis
        op.geomTransf('Linear', 1, '-jntOffset', 0, 0, 0, -HBeam / 2)
        op.geomTransf('Linear', 2, '-jntOffset', 0, HBeam / 2, 0, -HBeam / 2)
        AColi = BColi * HColi  # cross-sectional area
        ACole = BCole * HCole  # cross-sectional area
        EcC = 4700 * sqrt(fcC * MPa)
        IzColi = 1. / 12. * BColi * HColi ** 3  # Column moment of inertia
        IzCole = 1. / 12. * BCole * HCole ** 3  # Column moment of inertia
        EleTag = 1
        Elements = []
        for Nod_ini in range(num_nodes):
            if ListNodes[Nod_ini, 2] != Loc_heigth[-1]:
                Nod_end = Nod_ini + n_col_axes
                if ListNodes[Nod_ini, 2] == 0.:
                    gTr = 1
                    RZi = 0
                    RZe = HBeam / 2
                    LCol = ListNodes[Nod_end, 2] - ListNodes[Nod_ini, 2] - RZi - RZe
                else:
                    gTr = 2
                    RZi = HBeam / 2
                    RZe = HBeam / 2
                    LCol = ListNodes[Nod_end, 2] - ListNodes[Nod_ini, 2] - RZi - RZe
                if ListNodes[Nod_ini, 1] == 0. or ListNodes[Nod_ini, 1] == Loc_span[-1]:
                    BCol, HCol = BCole, HCole
                    ACol = ACole
                    IzCol = IFC * IzCole
                else:
                    BCol, HCol = BColi, HColi
                    ACol = AColi
                    IzCol = IFC * IzColi
                MassDens = ACol * GConc / g
                Elements.append(BeamElasticElement(EleTag, Nod_ini, Nod_end, ACol, EcC, IzCol, LCol, BCol, HCol, gTr,
                                                   RZi, RZe))
                op.element('elasticBeamColumn', EleTag, Nod_ini, Nod_end, ACol, EcC, IzCol, gTr, '-mass', MassDens,
                           MassType)
                EleTag += 1
        num_cols = EleTag

        # Beams creation for elastic analysis
        op.geomTransf('Linear', 3, '-jntOffset', HColi / 2., 0, -HColi / 2., 0)
        op.geomTransf('Linear', 4, '-jntOffset', HCole / 2., 0, -HColi / 2., 0)
        op.geomTransf('Linear', 5, '-jntOffset', HColi / 2., 0, -HCole / 2., 0)
        ABeam = BBeam * HBeam
        EcB = 4700 * sqrt(fcB * MPa)
        IzBeam = IFB * BBeam * HBeam ** 3 / 12
        MassDens = ABeam * GConc / g + WDLS / g
        for Nod_ini in range(num_nodes):
            if ListNodes[Nod_ini, 1] != Loc_span[-1] and ListNodes[Nod_ini, 2] != 0.:
                Nod_end = Nod_ini + 1
                if ListNodes[Nod_ini, 1] == 0.:
                    gTr = 4
                    RZi = HCole / 2.
                    RZe = HColi / 2.
                    LBeam = ListNodes[Nod_end, 1] - ListNodes[Nod_ini, 1] - RZi - RZe
                elif ListNodes[Nod_ini, 1] == Loc_span[-2]:
                    gTr = 5
                    RZi = HColi / 2.
                    RZe = HCole / 2.
                    LBeam = ListNodes[Nod_end, 1] - ListNodes[Nod_ini, 1] - RZi - RZe
                else:
                    gTr = 3
                    RZi = HColi / 2.
                    RZe = HColi / 2.
                    LBeam = ListNodes[Nod_end, 1] - ListNodes[Nod_ini, 1] - RZi - RZe
                Elements.append(BeamElasticElement(EleTag, Nod_ini, Nod_end, ABeam, EcB, IzBeam, LBeam, BBeam, HBeam,
                                                   gTr, RZi, RZe))
                op.element('elasticBeamColumn', EleTag, Nod_ini, Nod_end, ABeam, EcB, IzBeam, gTr,
                           '-mass', MassDens, MassType)
                EleTag += 1
        num_elems = EleTag
        num_beams = num_elems - num_cols

        # Create a Plain load pattern for gravity loading with a Linear TimeSeries
        Pvig = ABeam * GConc
        PColi = AColi * GConc
        PCole = ACole * GConc
        op.timeSeries('Linear', 1)
        op.pattern('Plain', 1, 1)
        for Element in Elements:
            if ListNodes[Element.Nod_ini, 1] == ListNodes[Element.Nod_end, 1]:
                if ListNodes[Element.Nod_ini, 1] == 0. or ListNodes[Element.Nod_ini, 1] == Loc_span[-1]:
                    PCol = PCole
                else:
                    PCol = PColi
                op.eleLoad('-ele', Element.EleTag, '-type', '-beamUniform', 0, -PCol)
            if ListNodes[Element.Nod_ini, 2] == ListNodes[Element.Nod_end, 2]:
                op.eleLoad('-ele', Element.EleTag, '-type', '-beamUniform', -Pvig - WDL)

        op.system('UmfPack')
        op.numberer('Plain')
        op.constraints('Plain')
        op.integrator('LoadControl', 1.0)
        op.algorithm('Linear')
        op.analysis('Static')
        op.analyze(1)
        ElemnsForceD = []
        for Element in Elements:
            Forces = op.eleForce(Element.EleTag)
            Forces.insert(0, Element.EleTag)
            ElemnsForceD.append(Forces)
        ElemnsForceD = np.array(ElemnsForceD)
        Wtotal = np.sum(ElemnsForceD[:len(Loc_span), 2]) * Lafs / Lafg

        op.loadConst('-time', 0.0)
        op.timeSeries('Linear', 2)
        op.pattern('Plain', 2, 1)
        for Element in Elements:
            if ListNodes[Element.Nod_ini, 2] == ListNodes[Element.Nod_end, 2]:
                op.eleLoad('-ele', Element.EleTag, '-type', '-beamUniform', -WLL)
        op.analyze(1)

        # Frame Geometry plot
#        self.ui.DataFrame.canvas.axes.clear()
#        self.ui.DataFrame.canvas.axes.plot(ListNodes[:, 1], ListNodes[:, 2], 'ks')
#
#        self.ui.DataFrame.canvas.axes.axis('off')
#        for Ele in Elements:
#            xi = ListNodes[Ele.Nod_ini, 1]
#            yi = ListNodes[Ele.Nod_ini, 2]
#            xe = ListNodes[Ele.Nod_end, 1]
#            ye = ListNodes[Ele.Nod_end, 2]
#            self.ui.DataFrame.canvas.axes.plot([xi, xe], [yi, ye], 'k-', alpha=.3)
#            if xi == xe:
#                self.ui.DataFrame.canvas.axes.text(xi, (ye + yi) / 2, r'C{}'.format(Ele.EleTag), style='italic',
#                                                   fontsize=8,
#                                                   rotation='vertical', verticalalignment='center')
#            if yi == ye:
#                self.ui.DataFrame.canvas.axes.text((xe + xi) / 2, yi, r'B{}'.format(Ele.EleTag), style='italic',
#                                                   fontsize=8,
#                                                   horizontalalignment='center')
#        self.ui.DataFrame.canvas.axes.axis('equal')
#        self.ui.DataFrame.canvas.draw()
#        self.ui.DataFrame.canvas.show()

        ElemnsForceDL = []
        for Element in Elements:
            Forces = op.eleForce(Element.EleTag)
            Forces.insert(0, Element.EleTag)
            ElemnsForceDL.append(Forces)
        ElemnsForceDL = np.array(ElemnsForceDL)

        # Create a Plain load pattern for seismic loading with a Linear TimeSeries (LLEF)
        op.loadConst('-time', 0.0)
        Htotal = Loc_heigth[-1]
        Ct = 0.0466
        x = 0.9
        Ta = Ct * Htotal ** x
        print('Ta =', Ta)
        Ie = 1.0
        Ts = Sd1 / Sds
        if Ta <= Ts:
            Sa = max(Sds * Ie / R, 0.044 * Sds * Ie, 0.01)
        elif Ta <= Tl:
            Sa = max(Sd1 * Ie / Ta / R, 0.044 * Sds * Ie, 0.01)
        else:
            Sa = max(Sd1 * Tl * Ie / (Ta ** 2) / R, 0.044 * Sds * Ie, 0.01)
        if Ta <= 0.5:
            k = 1.
        elif Ta <= 2.5:
            k = 0.75 + 0.5 * Ta
        else:
            k = 2.
        sumH = np.sum(np.power(Loc_heigth, k))

        op.timeSeries('Linear', 3)
        op.pattern('Plain', 3, 1)
        print('Wtotal =', Wtotal)
        Fp = Sa * Wtotal * np.power(Loc_heigth, k) / sumH
        print('FSis =', Fp)
        for (fp, ind) in zip(Fp, range(len(Loc_heigth))):
            op.load(int(ListNodesDrift[ind, 0]), fp, 0.0, 0.0)
        Vbasal = Sa * Wtotal

        op.analyze(1)
        ElemnsForceDLE = []
        for Element in Elements:
            Forces = op.eleForce(Element.EleTag)
            Forces.insert(0, Element.EleTag)
            ElemnsForceDLE.append(Forces)
        ElemnsForceDLE = np.array(ElemnsForceDLE)
        np.set_printoptions(precision=6)
        np.set_printoptions(suppress=True)

        # Story drift caculations
        DriftMax = 0.02
        nodesDisp = []
        Id_Node_Drift = ListNodesDrift[:, 0]
        Id_Node_Drift = np.int64(Id_Node_Drift)
        Id_Node_Drift = Id_Node_Drift.tolist()
        for nodo in Id_Node_Drift:
            nodesDisp.append([nodo, op.nodeDisp(nodo, 1)])
        nodesDisp = np.array(nodesDisp)
        drift = nodesDisp[1:, 1] - nodesDisp[:-1, 1]
        drift_p = np.divide(drift, np.array(heigth_v))
        ver_drift = np.where(drift_p < DriftMax, 'ok', 'not ok')
        Id_Floor = np.arange(1, len(Loc_heigth))
        drift_table = pd.DataFrame({"1.Floor": Id_Floor, "2.Drift": drift_p * 100, "3.": ver_drift})
        print(drift_table)

        # Beams and columns design procedures
        Beta1B = beta1(fcB)
        cover = 4 * cm
        dst = 3 / 8 * inch
        Ast = pi * dst ** 2 / 4.  # area de la barra del estribo
        ro_max_b = 0.85 * Beta1B * fcB * 3. / fy / 8.  # maximun steel percentage
        ro_min_b = max(0.25 * sqrt(fcB / MPa) * MPa / fy, 1.4 * MPa / fy)  # minimun steel percentage
        DataBeamDesing = []
        for (Ele, EleForceD, EleForceDL, EleForceDLE) in zip(Elements, ElemnsForceD, ElemnsForceDL, ElemnsForceDLE):
            if ListNodes[Ele.Nod_ini, 2] == ListNodes[Ele.Nod_end, 2]:
                VID = EleForceD[2]
                VIL = EleForceDL[2] - VID
                VIE = EleForceDLE[2] - VID - VIL
                VED = abs(EleForceD[5])
                VEL = abs(EleForceDL[5]) - VED
                VEE = abs(EleForceDLE[5]) - VED - VEL

                MID = EleForceD[3] - EleForceD[2]*Ele.RZi
                MIL = EleForceDL[3] - EleForceDL[2]*Ele.RZi - MID
                MIE = EleForceDLE[3] - EleForceDLE[2]*Ele.RZi - MID - MIL
                MED = EleForceD[6] + EleForceD[5]*Ele.RZe
                MEL = EleForceDL[6] + EleForceDL[5]*Ele.RZe - MED
                MEE = EleForceDLE[6] + EleForceDLE[5]*Ele.RZe - MED - MEL
                MED, MEL, MEE = -MED, -MEL, -MEE
                print('MID ', MID, 'MED', MED, 'MIL ', MIL, 'MEL', MEL, 'MIE ', MIE, 'MEE', MEE)
                MI1, MI2, MI3, MI4, MI5 = Combo_ACI(MID, MIL, MIE)
                MNU1 = max([MI1, MI2, MI3, MI4, MI5, 0.])  # Momento negativo nudo inicial de diseño
                MPU1 = min([MI1, MI2, MI3, MI4, MI5, abs(MNU1) / 3])  # Momento positivo nudo inicial de diseño
                ME1, ME2, ME3, ME4, ME5 = Combo_ACI(MED, MEL, MEE)
                MNU2 = max([ME1, ME2, ME3, ME4, ME5, 0.])  # Momento negativo nudo final de diseño
                MPU2 = min([ME1, ME2, ME3, ME4, ME5, abs(MNU2) / 3])  # Momento positivo nudo final de diseño
                Mmax = max([MNU1, -MPU1, MNU2, -MPU2])
                MNU1 = max([MNU1, Mmax / 5])
                MPU1 = min([MPU1, -Mmax / 5])
                MNU2 = max([MNU2, Mmax / 5])
                MPU2 = min([MPU2, -Mmax / 5])

                Ast1, dt1, Mn_N1, db_t1 = AsBeam(MNU1, Ele.EleTag)
                Asb1, db1, Mn_P1, db_b1 = AsBeam(MPU1, Ele.EleTag)
                Ast2, dt2, Mn_N2, db_t2 = AsBeam(MNU2, Ele.EleTag)
                Asb2, db2, Mn_P2, db_b2 = AsBeam(MPU2, Ele.EleTag)

                VI1 = 1.2 * VID + 1.6 * VIL
                VI2 = 1.2 * VID + 1.0 * VIL - 1.0 * VIE
                VI3 = 0.9 * VID - 1.0 * VIE
                VI4 = (Mn_P1 + Mn_N2) / Ele.LEle + (1.2 * WDL + WLL) * Ele.LEle / 2.
                VI5 = (Mn_N1 + Mn_P2) / Ele.LEle + (1.2 * WDL + WLL) * Ele.LEle / 2.
                VI6 = 1.2 * VID + 1.0 * VIL - 2.0 * VIE
                VI7 = 0.9 * VID - 2.0 * VIE

                VU1a = max(VI1, VI2, VI3)
                VU1b = max(VI4, VI5)
                VU1c = max(VI6, VI7)

                VU1 = max(VU1a, min(VU1b, VU1c))  # Cortante negativo nudo inicial de diseño

                VE1 = 1.2 * VED + 1.6 * VEL
                VE2 = 1.2 * VED + 1.0 * VEL + 1.0 * VEE
                VE3 = 0.9 * VED + 1.0 * VEE
                VE4 = (Mn_P1 + Mn_N2) / Ele.LEle + (1.2 * WDL + WLL) * Ele.LEle / 2.
                VE5 = (Mn_N1 + Mn_P2) / Ele.LEle + (1.2 * WDL + WLL) * Ele.LEle / 2.
                VE6 = 1.2 * VED + 1.0 * VEL + 2.0 * VEE
                VE7 = 0.9 * VED + 2.0 * VEE

                VU2a = max(VE1, VE2, VE3)
                VU2b = max(VE4, VE5)
                VU2c = max(VE6, VE7)

                VU2 = max(VU2a, min(VU2b, VU2c))  # Cortante negativo nudo final de diseño

                nst1, sst1 = AvBeam(VU1, db_t1, dt1, Ele.EleTag)
                nst2, sst2 = AvBeam(VU2, db_t2, dt2, Ele.EleTag)

                DataBeamDesing.append(BeamDesing(Ele.EleTag, BBeam, HBeam, Ast1, dt1, Mn_N1, Asb1, db1, Mn_P1, nst1,
                                                 sst1, Ast2, dt2, Mn_N2, Asb2, db2, Mn_P2, nst2, sst2, Ele.Nod_ini,
                                                 Ele.Nod_end, db_t1, db_b1, db_t2, db_b2))
                #self.ui.tbl_data_design_beams.setRowCount(0)
                #data_beams_table(self)

        # Column design procedure
        ro_min = 0.01
        ro_max = 0.08
        Beta1C = beta1(fcC)
        npts = 20
        ncom = 10
        ecu = 0.003
        Es = 200. * GPa

        db_v = np.array([5, 6, 7, 8, 9, 10, 11, 14, 18])  # vector de diametros de barras
        DataColDesing = []
        for (Ele, EleForceD, EleForceDL, EleForceDLE) in zip(Elements, ElemnsForceD, ElemnsForceDL, ElemnsForceDLE):
            if ListNodes[Ele.Nod_ini, 1] == ListNodes[Ele.Nod_end, 1]:
                Mn_N_R, Mn_P_R, Mn_N_L, Mn_P_L = 0, 0, 0, 0
                for DB in DataBeamDesing:
                    if Ele.Nod_end == DB.Nod_ini:
                        Mn_N_R, Mn_P_R = DB.Mn_n1, DB.Mn_p1
                    if Ele.Nod_end == DB.Nod_end:
                        Mn_N_L, Mn_P_L = DB.Mn_n2, DB.Mn_p2
                Sum_Mn_B = max(Mn_P_R + Mn_N_L, Mn_N_R + Mn_P_L)
                b, h = Ele.BEle, Ele.HEle
                nbB = ceil(b * 10)  # bars numbers along B
                nbH = ceil(h * 10)  # bars numbers along H
                D_c = 1.1 * h / npts
                nbH_v = np.array([nbH - 1, nbH, nbH + 1])
                nbB_v = np.array([nbB - 1, nbB, nbB + 1])

                MID = EleForceD[3]
                MIL = EleForceDL[3] - MID
                MIE = EleForceDLE[3] - MID - MIL

                PID = EleForceD[2]
                PIL = EleForceDL[2] - PID
                PIE = EleForceDLE[2] - PID - PIL

                MI1, MI2, MI3, MI4, MI5 = Combo_ACI(MID, MIL, MIE)
                PI1, PI2, PI3, PI4, PI5 = Combo_ACI(PID, PIL, PIE)

                MED = -EleForceD[6]
                MEL = -EleForceDL[6] - MED
                MEE = -EleForceDLE[6] - MED - MEL
                print('MID ', MID, 'MED', MED, 'MIL ', MIL, 'MEL', MEL, 'MIE ', MIE, 'MEE', MEE)

                PED = -EleForceD[5]
                PEL = -EleForceDL[5] - PED
                PEE = -EleForceDLE[5] - PED - PEL

                ME1, ME2, ME3, ME4, ME5 = Combo_ACI(MED, MEL, MEE)
                PE1, PE2, PE3, PE4, PE5 = Combo_ACI(PED, PEL, PEE)

                Nu_min = min([PI2, PI3, PI4, PI5, PE2, PE3, PE4, PE5])

                Pu_v = np.array([PI1, PI2, PI3, PI4, PI5, PE1, PE2, PE3, PE4, PE5])
                Mu_v = np.array([MI1, MI2, MI3, MI4, MI5, ME1, ME2, ME3, ME4, ME5])
                Mu_v = np.absolute(Mu_v)

                nbH, nbB, db, As, fiPn, fiMn, Mn_i, d, dist, ro, Mu_i = AsColumn()

                VID = EleForceD[1]
                VIL = EleForceDL[1] - VID
                VIE = EleForceDLE[1] - VID - VIL
                VID, VIL, VIE = abs(VID), abs(VIL), abs(VIE)

                Mu_is = Mu_i[[1, 2, 3, 4, 6, 7, 8, 9]]
                Mn_max = np.max(Mu_is)  # Momento maximo de todas las combo sismicas
                VI1, VI2, VI3, VI4, VI5 = Combo_ACI(VID, VIL, VIE)

                VI6 = 2.0 * Mn_max / Ele.LEle
                VI7 = 1.2 * VID + 1.0 * VIL + Omo * VIE
                VI8 = 1.2 * VID + 1.0 * VIL - Omo * VIE
                VI9 = 0.9 * VID + Omo * VIE
                VI10 = 0.9 * VID - Omo * VIE

                VUa = max([VI1, VI2, VI3, VI4, VI5])
                VUb = VI6
                VUc = max([VI7, VI8, VI9, VI10])

                Vu = max([VUa, min([VUb, VUc])])  # Cortante maximo de diseño
                sst, nsB, nsH = AvColumn()
                DataColDesing.append(ColDesing(Ele.EleTag, b, h, nbH, nbB, db, As, Pu_v, Mu_v, fiPn, fiMn, Mn_i, d,
                                               dist, ro, Mu_i, sst, nsB, nsH, Ele.Nod_ini, Ele.Nod_end))

            #self.ui.tbl_data_design_columns.setRowCount(0)
            #data_columns_table(self)
            #self.ui.tabWidget.setCurrentIndex(1)

    # Creation of the nonlinear model
    def CreateNLM(self,rootSIM,outputLogger, preparePushover):
        def __init__(rootSIM):
            self.rootSIM = rootSIM
            self.outputLogger = outputLogger
        
        global T1m, T2m, EleCol, EleBeam

        # Validation of beam and column design table data
        def validate_data(self):
            cover = 4*cm
            dst = 3/8*inch


            for DC in DataColDesing:
                dp = cover + dst + 0.5 * DC.db
                DC.dist = np.linspace(dp, DC.h - dp, DC.nbH)
                Ab = pi * DC.db ** 2. / 4.
                DC.As = np.hstack([DC.nbB * Ab, np.ones(DC.nbH - 2) * 2 * Ab, DC.nbB * Ab])
                
                # print("DC.EleTag",DC.EleTag)
                # print("DC.nbH",DC.nbH)
                # print("DC.db",DC.db)
                # print("Ab",Ab)
                # print("DC.nbB",DC.nbB)
                # print("DC.h",DC.h)
                # print("DC.b",DC.b)
                # print("dp",dp)
                # print("dst",dst)
                # print("cover",cover)
                # print("DC.As",DC.As)
                # print("DC.dist",DC.dist)


        # Function: Parameters of regularized unconfined concrete
        def con_inconf_regu():
            fpc = -fc
            epsc0 = 2 * fpc / Ec
            Gfc = max(2.0 * (-fpc / MPa) * N / mm, 25.0 * N / mm)
            epscu = Gfc / (0.6 * fpc * phl) - 0.8 * fpc / Ec + epsc0
            fcu = 0.2 * fpc
            lambdaU = 0.10
            ft = 0.33 * sqrt(-fpc * MPa)
            Ets = ft / 0.002
            return fpc, epsc0, fcu, epscu, lambdaU, ft, Ets

        # Function: Parameters of regularized confined concrete
        def con_conf_regu(b, h, nsB, nsH, sst):
            fpc = -fc
            bcx = h - 2. * cover - dst
            bcy = b - 2. * cover - dst
            Asx = nsB * Ast
            Asy = nsH * Ast
            Asvt = Asx + Asy
            flx = Asvt * fy / sst / bcx
            fly = Asvt * fy / sst / bcy
            slx = bcx / (nsB - 1)
            sly = bcy / (nsH - 1)
            k2x = min(0.26 * sqrt((bcx / sst) * (bcx / slx) * (1000. / flx)), 1)
            k2y = min(0.26 * sqrt((bcy / sst) * (bcy / sly) * (1000. / fly)), 1)
            flex = k2x * flx
            fley = k2y * fly
            fle = (flex * bcx + fley * bcy) / (bcx + bcy)
            k1 = 6.7 * (fle / 1000.) ** (-0.17)
            fcc = fc + k1 * fle
            fpcc = -fcc
            Ecc = Ec
            Gfc = max(2.0 * (-fpc / MPa) * N / mm, 25.0 * N / mm)
            K = k1 * fle / fc
            epscc0 = eo1 * (1. + 5. * K)
            Gfcc = 1.7 * Gfc
            epsccu = Gfcc / (0.6 * fpcc * phl) - 0.8 * fpcc / Ecc + epscc0
            fccu = 0.2 * fpcc
            lambdaC = 0.10
            ft = 0.33 * sqrt(-fpc * MPa)
            Ets = ft / 0.002
            
#            print("**** sst",sst)
#            print("**** fpc",fpc)
#            print("**** bcx",bcx)
#            print("**** bcy",bcy)
#            print("**** Asx",Asx)
#            print("**** Asy",Asy)
#            print("**** Asvt",Asvt)
#            print("**** flx",flx)
#            print("**** fly",fly)
#            print("**** slx",slx)
#            print("**** sly",sly)
#            print("**** k2x",k2x)
#            print("**** k2y",k2y)
#            print("**** flex",flex)
#            print("**** fley",fley)
#            print("**** fle",fle)
#            print("**** k1",k1)
#            print("**** fcc",fcc)
#            print("**** fpcc",fpcc)
#            print("**** Ecc",Ecc)
#            print("**** Gfc",Gfc)
#            print("**** K",K)
#            print("**** epscc0",epscc0)
#            print("**** Gfcc",Gfcc)
#            print("**** epsccu",epsccu)
#            print("**** fccu",fccu)
#            print("**** lambdaC",lambdaC)
#            print("**** ft",ft)
#            print("**** Ets",Ets)

            return fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets

        # Function: Regularized steel parameters
        def steel_mat_regu():
            FyTestN4 = 490.0 * MPa
            FsuTestN4 = 630.0 * MPa
            epsuTestN4 = 0.10
            LgageTestN4 = 200.0 * mm
            Es = 200.0 * GPa
            FyPosN4 = FyTestN4
            epsyPosN4 = FyPosN4 / Es
            FyNegN4 = FyTestN4
            epsyNegN4 = FyNegN4 / Es
            FsuPosN4 = FsuTestN4
            epsuPosN4 = epsyPosN4 + LgageTestN4 / phl * (epsuTestN4 - epsyPosN4)
            bPosN4 = (FsuPosN4 - FyPosN4) / (Es * (epsuPosN4 - epsyPosN4))
            epsuNegN4 = min(-epsccu, epsuPosN4)
            bNegN4 = bPosN4
            # FsuNegN4 = FsuTestN4
            FsuNegN4 = FyNegN4 + bNegN4 * (Es * (epsuNegN4 - epsyNegN4))
            FsrPosN4 = 0.2 * FyPosN4
            epsrPosN4 = (FsuPosN4 - FsrPosN4) / Es + 1.05 * epsuPosN4
            FsrNegN4 = 0.2 * FsuNegN4
            epsrNegN4 = (FsuNegN4 - FsrNegN4) / Es + 1.05 * epsuNegN4
            pinchX = 0.2
            pinchY = 0.8
            damage1 = 0.0
            damage2 = 0.0
            beta = 0.0
            # op.uniaxialMaterial('Hysteretic', Ele.EleTag * 6 + 4 + pos, FyPosN4, epsyPosN4, FsuPosN4, epsuPosN4
            #                     , FsrPosN4, epsrPosN4, -FyNegN4, -epsyNegN4, -FsuNegN4, -epsuNegN4, -FsrNegN4
            #                     , -epsrNegN4, pinchX, pinchY, damage1, damage2, beta)

            SteelN4Mat = Ele.EleTag * 6 + 4 + pos
            SteelMPFTag = 1e6 * SteelN4Mat
            R0 = 20.0
            cR1 = 0.925
            cR2 = 0.15
            a1 = 0.0
            a2 = 1.0
            a3 = 0.0
            a4 = 0.0
            print('SteelMPF', int(SteelMPFTag), FyPosN4, FyNegN4, Es, bPosN4, bNegN4, R0, cR1, cR2, a1, a2, a3, a4)
            op.uniaxialMaterial('SteelMPF', SteelMPFTag, FyPosN4, FyNegN4, Es, bPosN4, bNegN4, R0, cR1, cR2, a1, a2, a3, a4)
            outputLogger.add_array(['uniaxialMaterial','SteelMPF', int(SteelMPFTag), FyPosN4, FyNegN4, Es, bPosN4, bNegN4, R0, cR1, cR2, a1, a2, a3, a4])
            
            print('MinMax', int(SteelN4Mat), int(SteelMPFTag), '-min', -epsuNegN4, '-max', epsuPosN4)
            op.uniaxialMaterial('MinMax', SteelN4Mat, SteelMPFTag, '-min', -epsuNegN4, '-max', epsuPosN4)
            outputLogger.add_array(['uniaxialMaterial','MinMax', int(SteelN4Mat), int(SteelMPFTag), '-min', -epsuNegN4, '-max', epsuPosN4])

        # Function: Parameters of non-regularized confined concrete
        def con_conf(b, h, nsB, nsH, sst):
            fpc = -fc
            bcx = h - 2. * cover - dst
            bcy = b - 2. * cover - dst
            Asx = nsB * Ast
            Asy = nsH * Ast
            Asvt = Asx + Asy
            flx = Asvt * fy / sst / bcx
            fly = Asvt * fy / sst / bcy
            slx = bcx / (nsB - 1)
            sly = bcy / (nsH - 1)
            k2x = min(0.26 * sqrt((bcx / sst) * (bcx / slx) * (1000. / flx)), 1)
            k2y = min(0.26 * sqrt((bcy / sst) * (bcy / sly) * (1000. / fly)), 1)
            flex = k2x * flx
            fley = k2y * fly
            fle = (flex * bcx + fley * bcy) / (bcx + bcy)
            k1 = 6.7 * (fle / 1000.) ** (-0.17)
            fcc = fc + k1 * fle
            fpcc = -fcc
            K = k1 * fle / fc
            epscc0 = eo1 * (1. + 5. * K)
            rov = Asvt / sst / (bcx + bcy)
            e85 = 260 * rov * epscc0 + eo85
            epsccu = (e85 - epscc0) * (0.2 * fcc - fcc) / (0.85 * fcc - fcc) + epscc0
            fccu = 0.2 * fpcc
            lambdaC = 0.10
            ft = 0.33 * sqrt(-fpc * MPa)
            Ets = ft / 0.002
            return fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets

        # Function: Parameters of non-regularized steel
        def steel_mat():
            FyTestN4 = 490.0 * MPa
            FsuTestN4 = 630.0 * MPa
            epsuTestN4 = 0.10
            LgageTestN4 = phl
            Es = 200.0 * GPa
            FyPosN4 = FyTestN4
            epsyPosN4 = FyPosN4 / Es
            FyNegN4 = FyTestN4
            epsyNegN4 = FyNegN4 / Es
            FsuPosN4 = FsuTestN4
            epsuPosN4 = epsyPosN4 + LgageTestN4 / phl * (epsuTestN4 - epsyPosN4)
            bPosN4 = (FsuPosN4 - FyPosN4) / (Es * (epsuPosN4 - epsyPosN4))
            epsuNegN4 = min(-epsccu, epsuPosN4)
            bNegN4 = bPosN4
            # FsuNegN4 = FsuTestN4
            FsuNegN4 = FyNegN4 + bNegN4 * (Es * (epsuNegN4 - epsyNegN4))
            FsrPosN4 = 0.2 * FyPosN4
            epsrPosN4 = (FsuPosN4 - FsrPosN4) / Es + 1.05 * epsuPosN4
            FsrNegN4 = 0.2 * FsuNegN4
            epsrNegN4 = (FsuNegN4 - FsrNegN4) / Es + 1.05 * epsuNegN4
            pinchX = 0.2
            pinchY = 0.8
            damage1 = 0.0
            damage2 = 0.0
            beta = 0.0
            # op.uniaxialMaterial('Hysteretic', Ele.EleTag * 6 + 4 + pos, FyPosN4, epsyPosN4, FsuPosN4, epsuPosN4
            #                     , FsrPosN4, epsrPosN4, -FyNegN4, -epsyNegN4, -FsuNegN4, -epsuNegN4, -FsrNegN4
            #                     , -epsrNegN4, pinchX, pinchY, damage1, damage2, beta)

            SteelN4Mat = Ele.EleTag * 6 + 4 + pos
            SteelMPFTag = 1e6 * SteelN4Mat
            R0 = 20.0
            cR1 = 0.925
            cR2 = 0.15
            a1 = 0.0
            a2 = 1.0
            a3 = 0.0
            a4 = 0.0
            print('SteelMPF', int(SteelMPFTag), FyPosN4, FyNegN4, Es, bPosN4, bNegN4, R0, cR1, cR2, a1, a2, a3, a4)
            op.uniaxialMaterial('SteelMPF', SteelMPFTag, FyPosN4, FyNegN4, Es, bPosN4, bNegN4, R0, cR1, cR2, a1, a2, a3, a4)
            outputLogger.add_array(['uniaxialMaterial','SteelMPF', int(SteelMPFTag), FyPosN4, FyNegN4, Es, bPosN4, bNegN4, R0, cR1, cR2, a1, a2, a3, a4])

            print('MinMax', int(SteelN4Mat), int(SteelMPFTag), '-min', -epsuNegN4, '-max', epsuPosN4)
            op.uniaxialMaterial('MinMax', SteelN4Mat, SteelMPFTag, '-min', -epsuNegN4, '-max', epsuPosN4)
            outputLogger.add_array(['uniaxialMaterial','MinMax', int(SteelN4Mat), int(SteelMPFTag), '-min', -epsuNegN4, '-max', epsuPosN4])

        # Function: Creation of fibers in beams
        def fiber_beam(Ast, Asb, pos):
            op.section('Fiber', Ele.EleTag * 2 + pos)
            op.patch('rect', Ele.EleTag * 6 + pos, 10, 1, -y2 + dp, -z2 + dp, y2 - dp, z2 - dp)
            op.patch('rect', Ele.EleTag * 6 + 2 + pos, 10, 1, -y2 + dp, z2 - dp, y2 - dp, z2)
            op.patch('rect', Ele.EleTag * 6 + 2 + pos, 10, 1, -y2 + dp, -z2, y2 - dp, -z2 + dp)
            op.patch('rect', Ele.EleTag * 6 + 2 + pos, 2, 1, -y2, -z2, -y2 + dp, z2)
            op.patch('rect', Ele.EleTag * 6 + 2 + pos, 2, 1, y2 - dp, -z2, y2, z2)
            print('BeamL',Ele.EleTag * 6 + 4 + pos, 1, Ast, y2 - dp, z2 - dp, y2 - dp, -z2 + dp)
            op.layer('straight', Ele.EleTag * 6 + 4 + pos, 1, Ast, y2 - dp, z2 - dp, y2 - dp, -z2 + dp)
            print('BeamR',Ele.EleTag * 6 + 4 + pos, 1, Asb, -y2 + dp, z2 - dp, -y2 + dp, -z2 + dp)
            op.layer('straight', Ele.EleTag * 6 + 4 + pos, 1, Asb, -y2 + dp, z2 - dp, -y2 + dp, -z2 + dp)
            
            outputLogger.add_line('# Creating fibres in beam')
            
            outputLogger.add_array(['section','Fiber', Ele.EleTag * 2 + pos,'{'])
            outputLogger.add_array(['patch','rect', Ele.EleTag * 6 + pos, 10, 1, -y2 + dp, -z2 + dp, y2 - dp, z2 - dp])
            outputLogger.add_array(['patch','rect', Ele.EleTag * 6 + 2 + pos, 10, 1, -y2 + dp, z2 - dp, y2 - dp, z2])
            outputLogger.add_array(['patch','rect', Ele.EleTag * 6 + 2 + pos, 10, 1, -y2 + dp, -z2, y2 - dp, -z2 + dp])
            outputLogger.add_array(['patch','rect', Ele.EleTag * 6 + 2 + pos, 2, 1, -y2, -z2, -y2 + dp, z2])
            outputLogger.add_array(['patch','rect', Ele.EleTag * 6 + 2 + pos, 2, 1, y2 - dp, -z2, y2, z2])
            outputLogger.add_array(['layer','straight', Ele.EleTag * 6 + 4 + pos, 1, Ast, y2 - dp, z2 - dp, y2 - dp, -z2 + dp])
            outputLogger.add_array(['layer','straight', Ele.EleTag * 6 + 4 + pos, 1, Asb, -y2 + dp, z2 - dp, -y2 + dp, -z2 + dp])
            outputLogger.add_line('}')

        validate_data(self)
        op.wipe()  # The models is restarted in opensees
        outputLogger.add_line('wipe;')

        op.model('Basic', '-ndm', 2, '-ndf', 3)
        outputLogger.add_array(['model','Basic', '-ndm', 2, '-ndf', 3])

        outputLogger.add_line('# Create the nodes')

        for node in ListNodes:
            op.node(int(node[0]), int(node[1]), int(node[2]))
            outputLogger.add_array(['node',int(node[0]), int(node[1]), int(node[2])])

            if node[2] == 0.:
                op.fix(int(node[0]), 1, 1, 1)
                outputLogger.add_array(['fix',int(node[0]), 1, 1, 1])
            if node[2] > 0 and node[1] == 0:
                MasterNode = node[0]
            if node[2] > 0 and node[1] != 0:
                op.equalDOF(int(MasterNode), int(node[0]), 1)
                outputLogger.add_array(['equalDOF',int(MasterNode), int(node[0]), 1])

        cover = 4 * cm
        dst = 3 / 8 * inch
        Ast = pi * dst ** 2 / 4.  # area de la barra del estribo

        # creacion de columnas
        # HBeam = float(self.ui.HBeam.text())
        HBeam = float(rootSIM["BeamDepth"])
        
        # HColi = float(self.ui.HColi.text())  # Column inside Depth
        HColi = float(rootSIM["IntColDepth"])
        
        # HCole = float(self.ui.HCole.text())  # Column outside Depth
        HCole = float(rootSIM["ExtColDepth"])

        # fy = float(self.ui.fy.text()) * MPa
        fy = float(rootSIM["FySteel"]) * MPa

        Es = 200.0 * GPa
        
        # fcB = float(self.ui.fcB.text()) * MPa
        fcB = float(rootSIM["BeamFpc"]) * MPa

        # fcC = float(self.ui.fcC.text()) * MPa
        fcC = float(rootSIM["ColFpc"]) * MPa
        
        op.geomTransf('PDelta', 1, '-jntOffset', 0, 0, 0, -HBeam / 2)
        op.geomTransf('PDelta', 2, '-jntOffset', 0, HBeam / 2, 0, -HBeam / 2)
        op.geomTransf('Corotational', 3, '-jntOffset', HColi / 2., 0, -HColi / 2., 0)
        op.geomTransf('Corotational', 4, '-jntOffset', HCole / 2., 0, -HColi / 2., 0)
        op.geomTransf('Corotational', 5, '-jntOffset', HColi / 2., 0, -HCole / 2., 0)
        
        outputLogger.add_line('# Define the geometric transformations')

        outputLogger.add_array(['geomTransf','PDelta', 1, '-jntOffset', 0, 0, 0, -HBeam / 2])
        outputLogger.add_array(['geomTransf','PDelta', 2, '-jntOffset', 0, HBeam / 2, 0, -HBeam / 2])
        outputLogger.add_array(['geomTransf','Corotational', 3, '-jntOffset', HColi / 2., 0, -HColi / 2., 0])
        outputLogger.add_array(['geomTransf','Corotational', 4, '-jntOffset', HCole / 2., 0, -HColi / 2., 0])
        outputLogger.add_array(['geomTransf','Corotational', 5, '-jntOffset', HColi / 2., 0, -HCole / 2., 0])

        EleCol = []
        EleBeam = []
        for Ele in Elements:
            if ListNodes[Ele.Nod_ini, 1] == ListNodes[Ele.Nod_end, 1]:
                EleCol.append(Ele)
            else:
                EleBeam.append(Ele)
                
        platicHingeOpt = int(rootSIM["PlasticHingeOpt"])
        includeRegularization = bool(rootSIM["IncludeRegularization"])
        
        # print("platicHingeOpt",platicHingeOpt)
        # print("includeRegularization",includeRegularization)

        # Creation of non-linear elements (beams and columns)
        eo1, eo85, eo20, lambdaU = -0.002, -0.0038, -0.006, 0.1
        for (Ele, DC) in zip(EleCol, DataColDesing):
            
            outputLogger.add_line('# Creating materials and elements for column '+str(DC.EleTag))
                            
            fc, Ec = fcC, Ele.EcEle
            if platicHingeOpt == 1:
                phl = 0.5 * DC.h
            elif platicHingeOpt == 2:
                phl = 0.08 * Ele.LEle + 0.022 * fy / MPa * DC.db / mm
            elif platicHingeOpt == 3:
                phl = 0.05 * Ele.LEle + 0.1 * fy / MPa * DC.db / mm / sqrt(fc * MPa)
            
            if includeRegularization == True:
                fpc, epsc0, fcu, epscu, lambdaU, ft, Ets = con_inconf_regu()
                print('Concrete02', Ele.EleTag * 6, fpc, epsc0, fcu, epscu, lambdaU, ft, Ets)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6, fpc, epsc0, fcu, epscu, lambdaU, ft, Ets)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 1, fpc, epsc0, fcu, epscu, lambdaU, ft, Ets)
                
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6, fpc, epsc0, fcu, epscu, lambdaU, ft, Ets])
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 1, fpc, epsc0, fcu, epscu, lambdaU, ft, Ets])
                
                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf_regu(DC.b, DC.h, DC.nsB, DC.nsH, DC.sst)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 2, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 3, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets)
                
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 2, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets])
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 3, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets])
                
                pos = 0
                steel_mat_regu()
                pos = 1
                steel_mat_regu()
            # No regularization
            else :
                ft = 0.33 * sqrt(fcC * MPa)
                Ets = ft / 0.002
                print('Concrete02', Ele.EleTag * 6, -fcC, eo1, -0.2 * fcC, eo20, lambdaU, ft, Ets)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6, -fcC, eo1, -0.2 * fcC, eo20, lambdaU, ft, Ets)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 1, -fcC, eo1, -0.2 * fcC, eo20, lambdaU, ft, Ets)
                
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6, -fcC, eo1, -0.2 * fcC, eo20, lambdaU, ft, Ets])
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 1, -fcC, eo1, -0.2 * fcC, eo20, lambdaU, ft, Ets])
                
                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf(DC.b, DC.h, DC.nsB, DC.nsH, DC.sst)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 2, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 3, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets)
                
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 2, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets])
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 3, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets])
                
                pos = 0
                steel_mat()
                pos = 1
                steel_mat()

            dp = DC.dist[0]
            y1 = DC.h / 2.0
            z1 = DC.b / 2.0
            
            outputLogger.add_line('# Creating sections and fibres for element ' + str(Ele.EleTag))
            
            op.section('Fiber', Ele.EleTag)
            op.patch('rect', Ele.EleTag * 6 + 2, 10, 1, -y1 + dp, -z1 + dp, y1 - dp, z1 - dp)
            op.patch('rect', Ele.EleTag * 6, 10, 1, -y1 + dp, z1 - dp, y1 - dp, z1)
            op.patch('rect', Ele.EleTag * 6, 10, 1, -y1 + dp, -z1, y1 - dp, -z1 + dp)
            op.patch('rect', Ele.EleTag * 6, 2, 1, -y1, -z1, -y1 + dp, z1)
            op.patch('rect', Ele.EleTag * 6, 2, 1, y1 - dp, -z1, y1, z1)
            
            outputLogger.add_array(['section','Fiber', int(Ele.EleTag),'{'])
            outputLogger.add_array(['patch','rect', Ele.EleTag * 6 + 2, 10, 1, -y1 + dp, -z1 + dp, y1 - dp, z1 - dp])
            outputLogger.add_array(['patch','rect', Ele.EleTag * 6, 10, 1, -y1 + dp, z1 - dp, y1 - dp, z1])
            outputLogger.add_array(['patch','rect', Ele.EleTag * 6, 10, 1, -y1 + dp, -z1, y1 - dp, -z1 + dp])
            outputLogger.add_array(['patch','rect', Ele.EleTag * 6, 2, 1, -y1, -z1, -y1 + dp, z1])
            outputLogger.add_array(['patch','rect', Ele.EleTag * 6, 2, 1, y1 - dp, -z1, y1, z1])

            for dist, As in zip(DC.dist, DC.As):
                print('Col ', Ele.EleTag * 6 + 4, 1, As, -y1 + dist, z1 - dp, -y1 + dist, -z1 + dp)
                op.layer('straight', Ele.EleTag * 6 + 4, 1, As, -y1 + dist, z1 - dp, -y1 + dist, -z1 + dp)
                outputLogger.add_array(['layer','straight', Ele.EleTag * 6 + 4, 1, As, -y1 + dist, z1 - dp, -y1 + dist, -z1 + dp])

            outputLogger.add_line('}')

            MassDens = Ele.AEle * GConc / g
            op.beamIntegration('HingeRadau', Ele.EleTag, Ele.EleTag, phl, Ele.EleTag, phl, Ele.EleTag)
            
            # outputLogger.add_array(['beamIntegration','HingeRadau', Ele.EleTag, Ele.EleTag, phl, Ele.EleTag, phl, Ele.EleTag])
                
            op.element('forceBeamColumn', Ele.EleTag, Ele.Nod_ini, Ele.Nod_end, Ele.ElegTr, Ele.EleTag, '-mass', MassDens)
            
            intgrStr = '"HingeRadau' + ' ' + str(Ele.EleTag) + ' ' + str(phl) + ' ' +str(Ele.EleTag) + ' ' + str(phl) + ' ' + str(Ele.EleTag) + '"'
            outputLogger.add_array(['element', 'forceBeamColumn', Ele.EleTag, Ele.Nod_ini, Ele.Nod_end, Ele.ElegTr, intgrStr,'-mass', MassDens])

        for (Ele, DB) in zip(EleBeam, DataBeamDesing):
            fc, Ec, nsH = fcB, Ele.EcEle, 2
            if platicHingeOpt == 1:
                phl1 = 0.5 * DB.h
                phl2 = 0.5 * DB.h
            elif platicHingeOpt == 2:
                phl1 = 0.08 * Ele.LEle + 0.022 * fy / MPa * DB.db_t1 / mm
                phl2 = 0.08 * Ele.LEle + 0.022 * fy / MPa * DB.db_t2 / mm
            elif platicHingeOpt == 3:
                phl1 = 0.05 * Ele.LEle + 0.1 * fy / MPa * DB.db_t1 / mm / sqrt(fc * MPa)
                phl2 = 0.05 * Ele.LEle + 0.1 * fy / MPa * DB.db_t2 / mm / sqrt(fc * MPa)
            
            outputLogger.add_line('# Creating materials and elements for beam '+str(DB.EleTag))

            if includeRegularization == True:
                phl = phl1
                fpc, epsc0, fcu, epscu, lambdaU, ft, Ets = con_inconf_regu()
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6, fpc, epsc0, fcu, epscu, lambdaU, ft, Ets)
                outputLogger.add_array(['uniaxialMaterial', 'Concrete02', Ele.EleTag * 6, fpc, epsc0, fcu, epscu, lambdaU, ft, Ets])

                phl = phl2
                fpc, epsc0, fcu, epscu, lambdaU, ft, Ets = con_inconf_regu()
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 1, fpc, epsc0, fcu, epscu, lambdaU, ft, Ets)
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 1, fpc, epsc0, fcu, epscu, lambdaU, ft, Ets])

                phl, pos = phl1, 0
                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf_regu(DB.b, DB.h, DB.ns1, nsH, DB.ss1)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 2, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets)
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 2, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets])

                steel_mat_regu()
                phl, pos = phl2, 1
                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf_regu(DB.b, DB.h, DB.ns2, nsH, DB.ss2)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 3, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets)
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 3, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets])

                steel_mat_regu()
            # No regularization
            else:
                ft = 0.33 * sqrt(fcB * MPa)
                Ets = ft / 0.002
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6, -fcB, eo1, -0.2 * fcB, eo20, lambdaU, ft, Ets)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 1, -fcB, eo1, -0.2 * fcB, eo20, lambdaU, ft, Ets)
                
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6, -fcB, eo1, -0.2 * fcB, eo20, lambdaU, ft, Ets])
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 1, -fcB, eo1, -0.2 * fcB, eo20, lambdaU, ft, Ets])
                
                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf(DB.b, DB.h, DB.ns1, nsH, DB.ss1)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 2, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets)
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 2, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets])

                fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets = con_conf(DB.b, DB.h, DB.ns2, nsH, DB.ss2)
                op.uniaxialMaterial('Concrete02', Ele.EleTag * 6 + 3, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets)
                outputLogger.add_array(['uniaxialMaterial','Concrete02', Ele.EleTag * 6 + 3, fpcc, epscc0, fccu, epsccu, lambdaC, ft, Ets])
                
                pos = 0
                steel_mat()
                pos = 1
                steel_mat()
            y2 = DB.h / 2.0
            z2 = DB.b / 2.0
            dp = DB.h - min(DB.db1, DB.dt1)
            pos = 0
            
            fiber_beam(DB.Ast1, DB.Asb1, pos)
            dp = DB.h - min(DB.db2, DB.dt2)
            pos = 1
            fiber_beam(DB.Ast2, DB.Asb2, pos)
            MassDens = Ele.AEle * GConc / g + WDLS / g
            op.beamIntegration('HingeRadau', Ele.EleTag, Ele.EleTag * 2, phl1, Ele.EleTag * 2 + 1, phl2, Ele.EleTag * 2)
            #outputLogger.add_array(['beamIntegration','HingeRadau', Ele.EleTag, Ele.EleTag * 2, phl1, Ele.EleTag * 2 + 1, phl2, Ele.EleTag * 2])

            op.element('forceBeamColumn', Ele.EleTag, Ele.Nod_ini, Ele.Nod_end, Ele.ElegTr, Ele.EleTag, '-mass', MassDens)
            
            intgrStr = '"HingeRadau' + ' ' + str(Ele.EleTag * 2) + ' ' + str(phl1) + ' ' +str(Ele.EleTag * 2 + 1) + ' ' + str(phl2) + ' ' + str( Ele.EleTag * 2) + '"'
            outputLogger.add_array(['element','forceBeamColumn', Ele.EleTag, Ele.Nod_ini, Ele.Nod_end, Ele.ElegTr, intgrStr, '-mass', MassDens])

        list_beams = [Ele.EleTag for Ele in EleBeam]
        list_cols = [Ele.EleTag for Ele in EleCol]
        print('list_beams =', list_beams)
        print('list_cols =', list_cols)
        
        print("Model Nonlinear Built")

        if preparePushover == False:
            return

        if not os.path.exists("Pushover"):
            os.mkdir("Pushover")

        # Recording of forces and deformations from nonlinear analysis
        op.recorder('Element', '-file', 'Pushover/beams_force_1.out',
                    '-time', '-ele', *list_beams, 'section', 1, 'force')
        op.recorder('Element', '-file', 'Pushover/beams_def_1.out',
                    '-time', '-ele', *list_beams, 'section', 1, 'deformation')
        op.recorder('Element', '-file', 'Pushover/beams_force_6.out',
                    '-time', '-ele', *list_beams, 'section', 6, 'force')
        op.recorder('Element', '-file', 'Pushover/beams_def_6.out',
                    '-time', '-ele', *list_beams, 'section', 6, 'deformation')
        op.recorder('Element', '-file', 'Pushover/cols_force_1.out',
                    '-time', '-ele', *list_cols, 'section', 1, 'force')
        op.recorder('Element', '-file', 'Pushover/cols_def_1.out',
                    '-time', '-ele', *list_cols, 'section', 1, 'deformation')
        op.recorder('Element', '-file', 'Pushover/cols_force_6.out',
                    '-time', '-ele', *list_cols, 'section', 6, 'force')
        op.recorder('Element', '-file', 'Pushover/cols_def_6.out',
                    '-time', '-ele', *list_cols, 'section', 6, 'deformation')
        op.recorder('Node', '-file', 'Pushover/HoriNodes.out',
                    '-time', '-node', *ListNodes, '-dof', 1, 'disp')
        op.recorder('Node', '-file', 'Pushover/VertNodes.out',
                    '-time', '-node', *ListNodes, '-dof', 2, 'disp')

        # Create a Plain load pattern for gravity loading with a Linear TimeSeries
        op.timeSeries('Linear', 1)
        op.pattern('Plain', 1, 1)
        for Ele in EleCol:
            op.eleLoad('-ele', Ele.EleTag, '-type', '-beamUniform', 0, -Ele.AEle * GConc)
        for Ele in EleBeam:
            op.eleLoad('-ele', Ele.EleTag, '-type', '-beamUniform', -Ele.AEle * GConc - WDL)

        Tol = 1.0e-6  # convergence tolerance for test
        op.constraints('Plain')  # how it handles boundary conditions
        op.numberer('Plain')  # renumber dof to minimize band-width (optimization), if you want to
        op.system('BandGeneral')  # how to store and solve the system of equations in the analysis
        op.test('NormDispIncr', Tol, 100)  # determine if convergence has been achieved at the end of an iteration step
        op.algorithm('KrylovNewton')  # use Newton solution algorithm: updates tangent stiffness at every iteration
        NstepGravity = 10  # apply gravity in 10 steps
        DGravity = 1. / NstepGravity  # first load increment;
        op.integrator('LoadControl', DGravity)  # determine the next time step for an analysis
        op.analysis('Static')  # define type of analysis static or transient
        op.analyze(NstepGravity)  # apply gravity
        op.loadConst('-time', 0.0)

        xi = 0.05  # damping ratio
        MpropSwitch = 1.0
        KcurrSwitch = 0.0
        KcommSwitch = 1.0
        KinitSwitch = 0.0
        nEigenI = 1  # mode 1
        nEigenI2 = 2  # mode 2
        nEigenJ = 3  # mode 3
        lambdaN = op.eigen(nEigenJ)  # eigenvalue analysis for nEigenJ modes
        lambdaI = lambdaN[nEigenI - 1]  # eigenvalue mode i
        lambdaI2 = lambdaN[nEigenI2 - 1]  # eigenvalue mode i2
        lambdaJ = lambdaN[nEigenJ - 1]  # eigenvalue mode j
        print('lambdaN ', lambdaN)
        omegaI = pow(lambdaI, 0.5)
        omegaI2 = pow(lambdaI2, 0.5)
        omegaJ = pow(lambdaJ, 0.5)
        T1m = 2. * pi / omegaI
        T2m = 2. * pi / omegaI2

        print('Ta1=', T1m, 'seg', ' Ta2=', T2m, ' seg')
        alphaM = MpropSwitch * xi * (2. * omegaI * omegaJ) / (omegaI + omegaJ)  # M-prop. damping D = alphaM*M
        betaKcurr = KcurrSwitch * 2. * xi / (omegaI + omegaJ)  # current-K      +beatKcurr*KCurrent
        betaKcomm = KcommSwitch * 2. * xi / (omegaI + omegaJ)  # last-committed K   +betaKcomm*KlastCommitt
        betaKinit = KinitSwitch * 2. * xi / (omegaI + omegaJ)  # initial-K     +beatKinit*Kini
        op.rayleigh(alphaM, betaKcurr, betaKinit, betaKcomm)  # RAYLEIGH damping


    # Pushover function
    def Pushover(self, rootSIM):
        def __init__(rootSIM):
            self.rootSIM = rootSIM
            
        global cbar
        def singlePush1(dref, mu, ctrlNode, dispDir, nSteps):
            IOflag = 2
            testType = 'RelativeNormDispIncr'
            # set testType	EnergyIncr;					# Dont use with Penalty constraints
            # set testType	RelativeNormUnbalance;		# Dont use with Penalty constraints
            # set testType	RelativeNormDispIncr;		# Dont use with Lagrange constraints
            # set testType	RelativeTotalNormDispIncr;	# Dont use with Lagrange constraints
            # set testType	RelativeEnergyIncr;			# Dont use with Penalty constraints
            tolInit = 1.0e-6  # the initial Tolerance, so it can be referred back to
            iterInit = 50  # the initial Max Number of Iterations
            algorithmType = 'KrylovNewton'  # the algorithm type

            op.test(testType, tolInit
                    , iterInit)  # determine if convergence has been achieved at the end of an iteration step
            op.algorithm(algorithmType)  # use Newton solution algorithm: updates tangent stiffness at every iteration
            disp = dref * mu
            dU = disp / (1.0 * nSteps)
            print('dref ', dref, 'mu ', mu, 'dU ', dU, 'disp ', disp)
            op.integrator('DisplacementControl', ctrlNode, dispDir, dU)  # determine the next time step for an analysis
            op.analysis('Static')  # define type of analysis static or transient

            # Print values
            if IOflag >= 1:
                print('singlePush: Push ', ctrlNode, ' to ', mu)

            #      the initial values to start the while loop
            ok = 0
            step = 1
            loadf = 1.0
            # This feature of disabling the possibility of having a negative loading has been included.
            # This has been adapted from a similar script by Prof. Garbaggio
            htot = op.nodeCoord(ctrlNode, 2)
            maxDriftPiso = 0.0
            VBasal_v = []
            DriftTecho_v = []
            while step <= nSteps and ok == 0 and loadf > 0:
                #self.ui.progressBar.setValue(100 * step / nSteps)
                ok = op.analyze(1)
                loadf = op.getTime()
                temp = op.nodeDisp(ctrlNode, dispDir)
                # Print the current displacement
                if IOflag >= 2:
                    print('Pushed ', ctrlNode, ' in ', dispDir, ' to ', temp, ' with ', loadf, 'step', step)

                # If the analysis fails, try the following changes to achieve convergence
                # Analysis will be slower in here though...
                if ok != 0:
                    print('Trying relaxed convergence..')
                    op.test(testType, tolInit * 0.01,
                            iterInit * 50)  # determine if convergence has been achieved at the end of an iteration step
                    ok = op.analyze(1)
                    op.test(testType, tolInit,
                            iterInit)  # determine if convergence has been achieved at the end of an iteration step
                if ok != 0:
                    print('Trying Newton with initial then current .')
                    op.test(testType, tolInit * 0.01,
                            iterInit * 50)  # determine if convergence has been achieved at the end of an iteration step
                    op.algorithm('Newton', '-initialThenCurrent')
                    ok = op.analyze(1)
                    op.algorithm(algorithmType)
                    op.test(testType, tolInit,
                            iterInit)  # determine if convergence has been achieved at the end of an iteration step
                if ok != 0:
                    print('Trying ModifiedNewton with initial ..')
                    op.test(testType, tolInit * 0.01,
                            iterInit * 50)  # determine if convergence has been achieved at the end of an iteration step
                    op.algorithm('ModifiedNewton', '-initial')
                    ok = op.analyze(1)
                    op.algorithm(algorithmType)
                    op.test(testType, tolInit,
                            iterInit)  # determine if convergence has been achieved at the end of an iteration step
                if ok != 0:
                    print('Trying KrylovNewton ..')
                    op.test(testType, tolInit * 0.01,
                            iterInit * 50)  # determine if convergence has been achieved at the end of an iteration step
                    op.algorithm('KrylovNewton')
                    ok = op.analyze(1)
                    op.algorithm(algorithmType)
                    op.test(testType, tolInit,
                            iterInit)  # determine if convergence has been achieved at the end of an iteration step
                if ok != 0:
                    print('Perform a Hail Mary ....')
                    op.test('FixedNumIter',
                            iterInit)  # determine if convergence has been achieved at the end of an iteration step
                    ok = op.analyze(1)

                for (nod_ini, nod_end) in zip(ListNodesDrift[:-1, 0], ListNodesDrift[1:, 0]):
                    # print('nod_ini ', nod_ini, 'nod_end', nod_end)
                    nod_ini = int(nod_ini)
                    nod_end = int(nod_end)
                    pos_i = op.nodeCoord(nod_ini, 2)
                    pos_s = op.nodeCoord(nod_end, 2)
                    hpiso = pos_s - pos_i
                    desp_i = op.nodeDisp(nod_ini, 1)
                    desp_s = op.nodeDisp(nod_end, 1)
                    desp_piso = abs(desp_s - desp_i)
                    drift_piso = desp_piso / hpiso
                    if drift_piso >= maxDriftPiso:
                        maxDriftPiso = drift_piso

                VBasal = 0.
                op.reactions()
                for node in ListNodesBasal:
                    # print('ind Basal ', node[0])
                    VBasal = VBasal + op.nodeReaction(node[0], 1)
                VBasal_v = np.append(VBasal_v, VBasal)
                DriftTecho = op.nodeDisp(ctrlNode, dispDir) / htot
                DriftTecho_v = np.append(DriftTecho_v, DriftTecho)
                loadf = op.getTime()
                step += 1
            maxDriftTecho = dU * step / htot
            maxDriftTecho2 = op.nodeDisp(ctrlNode, dispDir) / htot

            if ok != 0:
                print('DispControl Analysis FAILED')
            else:
                print('DispControl Analysis SUCCESSFUL')
            if loadf <= 0:
                print('Stopped because of Load factor below zero: ', loadf)
            #    if PrintFlag == 0:
            #        os.remove("singlePush.txt")
            #        print singlePush.txt
            return maxDriftPiso, maxDriftTecho, maxDriftTecho2, VBasal_v, DriftTecho_v

        # Pushover function varying tests and algorithms
        def singlePush(dref, mu, ctrlNode, dispDir, nSteps):
            # --------------------------------------------------
            # Description of Parameters
            # --------------------------------------------------
            # dref:			Reference displacement to which cycles are run. Corresponds to yield or equivalent other, such as 1mm
            # mu:			Multiple of dref to which the push is run. So pushover can be run to a specifived ductility or displacement
            # ctrlNode:		Node to control with the displacement integrator.
            # dispDir:		DOF the loading is applied.
            # nSteps:		Number of steps.
            # IOflag:		Option to print details on screen. 2 for print of each step, 1 for basic info (default), 0 for off
            # ---------------------------------------------------
            test = {1: 'NormDispIncr', 2: 'RelativeEnergyIncr', 3: 'EnergyIncr',
                    4: 'RelativeNormUnbalance', 5: 'RelativeNormDispIncr',
                    6: 'NormUnbalance', 7: 'FixedNumIter'}
            alg = {1: 'KrylovNewton', 2: 'SecantNewton', 3: 'ModifiedNewton',
                   4: 'RaphsonNewton', 5: 'PeriodicNewton', 6: 'BFGS',
                   7: 'Broyden', 8: 'NewtonLineSearch'}

            # test = {1:'NormDispIncr', 2: 'RelativeEnergyIncr', 3:'EnergyIncr'}
            # alg = {1:'KrylovNewton', 2:'ModifiedNewton'}

            IOflag = 2
            PrintFlag = 0
            testType = 'RelativeNormDispIncr'  # Dont use with Penalty constraints

            tolInit = 1.0e-7  # the initial Tolerance, so it can be referred back to
            iterInit = 50  # the initial Max Number of Iterations
            algorithmType = 'KrylovNewton'  # the algorithm type
            #      	algorithmType Newton;		#      the algorithm type
            #      	algorithmType Newton;		#      the algorithm type

            # op.constraints('Transformation') # how it handles boundary conditions
            # op.numberer('RCM')    # renumber dof to minimize band-width (optimization), if you want to
            # op.system('BandGeneral') # how to store and solve the system of equations in the analysis

            op.test(testType, tolInit,
                    iterInit)  # determine if convergence has been achieved at the end of an iteration step
            op.algorithm(algorithmType)  # use Newton solution algorithm: updates tangent stiffness at every iteration
            disp = dref * mu
            dU = disp / (1.0 * nSteps)
            print('dref ', dref, 'mu ', mu, 'dU ', dU, 'disp ', disp, 'nSteps ', nSteps)
            op.integrator('DisplacementControl', ctrlNode, dispDir, dU)  # determine the next time step for an analysis
            op.analysis('Static')  # defivne type of analysis static or transient

            # Print values
            if IOflag >= 1:
                print('singlePush: Push ', ctrlNode, ' to ', mu)

            #      the initial values to start the while loop
            ok = 0
            step = 1
            loadf = 1.0
            # This feature of disabling the possibility of having a negative loading has been included.
            # This has been adapted from a similar script by Prof. Garbaggio
            maxDriftPiso = 0.0
            htot = op.nodeCoord(ctrlNode, 2)
            VBasal_v = []
            DriftTecho_v = []
            # factor_v = np.array([1,0.75,0.5,0.25,0.1,2,3,5,10])
            # fact_v = np.array([50,100,500])
            # factor = 100
            # fact = 1.
            while step <= nSteps and ok == 0 and loadf > 0:
                #self.ui.progressBar.setValue(100 * step / nSteps)
                ok = op.analyze(1)
                loadf = op.getTime()
                temp = op.nodeDisp(ctrlNode, dispDir)
                if IOflag >= 2:
                    print('Pushed ', ctrlNode, ' in ', dispDir, ' to ', temp, ' with ', loadf, 'step ', step)
                # for factor in factor_v:
                # op.integrator('DisplacementControl',ctrlNode,dispDir,factor*dU)  # determine the next time step for an analysis
                # for fact in fact_v:
                for j in alg:
                    for i in test:
                        for fact in [1, 20, 50]:
                            if ok != 0 and j >= 4 and i != 7:
                                # print('Trying ',str(alg[j]))
                                op.test(test[i], tolInit * .01, iterInit * fact)
                                op.algorithm(alg[j])
                                ok = op.analyze(1)
                                op.algorithm(algorithmType)
                                op.test(testType, tolInit, iterInit)
                            elif ok != 0 and j < 4 and i != 7:
                                # print('Trying ',str(alg[j]))
                                op.test(test[i], tolInit, iterInit * fact)
                                op.algorithm(alg[j], '-initial')
                                ok = op.analyze(1)
                                op.algorithm(algorithmType)
                                op.test(testType, tolInit, iterInit)
                            if ok == 0:
                                break
                        if ok != 0 and i == 7:
                            op.test(test[i], iterInit)
                            op.algorithm(alg[j])
                            ok = op.analyze(1)
                        if ok == 0:
                            break
                    if ok == 0:
                        break
                    # if ok == 0:
                    #     break
                    # if ok == 0:
                    #     break
                # op.integrator('DisplacementControl',ctrlNode,dispDir,dU)  # determine the next time step for an analysis
                # Calculation of maximum Drift between floors
                for (nod_ini, nod_end) in zip(ListNodesDrift[:-1, 0], ListNodesDrift[1:, 0]):
                    # print('nod_ini ', nod_ini, 'nod_end', nod_end)
                    nod_ini = int(nod_ini)
                    nod_end = int(nod_end)
                    pos_i = op.nodeCoord(nod_ini, 2)
                    pos_s = op.nodeCoord(nod_end, 2)
                    hpiso = pos_s - pos_i
                    desp_i = op.nodeDisp(nod_ini, 1)
                    desp_s = op.nodeDisp(nod_end, 1)
                    desp_piso = abs(desp_s - desp_i)
                    drift_piso = desp_piso / hpiso
                    if drift_piso >= maxDriftPiso:
                        maxDriftPiso = drift_piso

                VBasal = 0.
                op.reactions()
                for node in ListNodesBasal:
                    # print('ind Basal ', node[0])
                    VBasal = VBasal + op.nodeReaction(node[0], 1)
                VBasal_v = np.append(VBasal_v, VBasal)
                DriftTecho = op.nodeDisp(ctrlNode, dispDir) / htot
                DriftTecho_v = np.append(DriftTecho_v, DriftTecho)
                loadf = op.getTime()
                step += 1
            maxDriftTecho = dU * step / htot
            maxDriftTecho2 = op.nodeDisp(ctrlNode, dispDir) / htot

            if ok != 0:
                print('DispControl Analysis FAILED')
            else:
                print('DispControl Analysis SUCCESSFUL')
            if loadf <= 0:
                print('Stopped because of Load factor below zero: ', loadf)
            #    if PrintFlag == 0:
            #        os.remove("singlePush.txt")
            #        print singlePush.txt
            return maxDriftPiso, maxDriftTecho, maxDriftTecho2, VBasal_v, DriftTecho_v

        ListNodesDrift = ListNodes[np.where(ListNodes[:, 1] == 0.)]
        ListNodesBasal = ListNodes[np.where(ListNodes[:, 2] == 0.)]
        if T1m <= 0.5:
            k = 1.
        elif T1m <= 2.5:
            k = 0.75 + 0.5 * T1m
        else:
            k = 2.

        sumH = np.sum(np.power(Loc_heigth, k))
        floors_num = len(Loc_heigth)
        
        # Match default example
        triangForceDist = True

        # Defining the pushover lateral distribution type
        if triangForceDist == True:
            Fp = np.power(Loc_heigth, k) / sumH
        else:
            Fp = 1. / floors_num * np.ones(floors_num + 1)
        print('Fp =', Fp)
        op.loadConst('-time', 0.0)
        op.timeSeries('Linear', 2)
        op.pattern('Plain', 2, 1)
        for (node, fp, ind) in zip(ListNodesDrift, Fp, range(floors_num)):
            op.load(int(node[0]), fp, 0.0, 0.0)

        Htotal = Loc_heigth[-1]
#        Der_obj = float(self.ui.Der_obj.text())
        Der_obj = 0.04 # Match default example
        Des_obj = Der_obj * Htotal  # Desplazamiento objetivo
#        nSteps = int(self.ui.nSteps.text())
        nSteps = 110 # Match default example
        dref = Des_obj / nSteps
        mu = nSteps
        IDctrlNode = int(ListNodesDrift[-1, 0])  # Node where displacement is read
        print('IDctrlNode =', IDctrlNode)
        IDctrlDOF = 1  # DOF x=1, y=2
        Tol = 1.0e-4  # Tolerance

        runFastPushover = True
        if runFastPushover == True:
            maxDriftPiso, maxDriftTecho, maxDriftTecho2, VBasal_v, DriftTecho_v = singlePush1(dref, mu, IDctrlNode,
                                                                                              IDctrlDOF, nSteps)
        else:
            maxDriftPiso, maxDriftTecho, maxDriftTecho2, VBasal_v, DriftTecho_v = singlePush(dref, mu, IDctrlNode,
                                                                                             IDctrlDOF, nSteps)

        op.wipe()

        # Reading of forces and deflections of beams and columns from recorders
        beams_force_1 = np.loadtxt('Pushover/beams_force_1.out')
        beams_def_1 = np.loadtxt('Pushover/beams_def_1.out')
        beams_force_6 = np.loadtxt('Pushover/beams_force_6.out')
        beams_def_6 = np.loadtxt('Pushover/beams_def_6.out')
        cols_force_1 = np.loadtxt('Pushover/cols_force_1.out')
        cols_def_1 = np.loadtxt('Pushover/cols_def_1.out')
        cols_force_6 = np.loadtxt('Pushover/cols_force_6.out')
        cols_def_6 = np.loadtxt('Pushover/cols_def_6.out')
        print('cols_def_1', cols_def_1)

        # fy = float(self.ui.fy.text()) * MPa
        fy = float(rootSIM["FySteel"]) * MPa
        print("Fy",fy)
                
        Es = 200.0 * GPa
        ey = fy / Es
        num_beams = len(EleBeam)
        num_cols = len(EleCol)
        CD_Beams = np.zeros([num_beams, 2])

        # Calculation of curvature ductility of beams and columns
        for (ind, DB) in zip(range(1, num_beams + 1), DataBeamDesing):
            ets_beam_1 = beams_def_1[:, 2 * ind - 1] + beams_def_1[:, 2 * ind] * (DB.dt1-DB.h/2)
            ebs_beam_1 = beams_def_1[:, 2 * ind - 1] + beams_def_1[:, 2 * ind] * (DB.h/2-DB.db1)
            ets_beam_6 = beams_def_6[:, 2 * ind - 1] + beams_def_6[:, 2 * ind] * (DB.dt2-DB.h/2)
            ebs_beam_6 = beams_def_6[:, 2 * ind - 1] + beams_def_6[:, 2 * ind] * (DB.h/2-DB.db1)
            es_beam_1 = np.maximum(np.absolute(ets_beam_1), np.absolute(ebs_beam_1))
            es_beam_6 = np.maximum(np.absolute(ets_beam_6), np.absolute(ebs_beam_6))
            print('es_beam_1', es_beam_1, 'es_beam_6', es_beam_6)
            if np.max(es_beam_1) <= ey:
                CD_1 = 0
            else:
                fi_1 = np.absolute(beams_def_1[:, 2 * ind])
                M_beam_1 = np.absolute(beams_force_1[:, 2 * ind])
                f = interpolate.interp1d(es_beam_1, M_beam_1)
                My_1 = f(ey)
                f = interpolate.interp1d(M_beam_1, fi_1)
                fiy_1 = f(My_1)
                CD_1 = fi_1[-1] / fiy_1
            if np.max(es_beam_6) <= ey:
                CD_6 = 0
            else:
                fi_6 = np.absolute(beams_def_6[:, 2 * ind])
                M_beam_6 = np.absolute(beams_force_6[:, 2 * ind])
                f = interpolate.interp1d(es_beam_6, M_beam_6)
                My_6 = f(ey)
                f = interpolate.interp1d(M_beam_6, fi_6)
                fiy_6 = f(My_6)
                CD_6 = fi_6[-1] / fiy_6
            CD_Beams[ind - 1, :] = [CD_1, CD_6]
            print('CD_Beams =', CD_Beams)

        CD_Cols = np.zeros([num_cols, 2])
        for (ind, DC) in zip(range(1, num_cols + 1), DataColDesing):
            ets_col_1 = cols_def_1[:, 2 * ind - 1] + cols_def_1[:, 2 * ind] * (DC.d-DC.h/2)
            ebs_col_1 = cols_def_1[:, 2 * ind - 1] + cols_def_1[:, 2 * ind] * (DC.h/2-DC.d)
            ets_col_6 = cols_def_6[:, 2 * ind - 1] + cols_def_6[:, 2 * ind] * (DC.d-DC.h/2)
            ebs_col_6 = cols_def_6[:, 2 * ind - 1] + cols_def_6[:, 2 * ind] * (DC.h/2-DC.d)
            es_col_1 = np.maximum(np.absolute(ets_col_1), np.absolute(ebs_col_1))
            es_col_6 = np.maximum(np.absolute(ets_col_6), np.absolute(ebs_col_6))
            print('es_col_1', es_col_1, 'es_col_6', es_col_6)
            if np.max(es_col_1) <= ey:
                CD_1 = 0
            else:
                fi_1 = np.absolute(cols_def_1[:, 2 * ind])
                M_col_1 = np.absolute(cols_force_1[:, 2 * ind])
                f = interpolate.interp1d(es_col_1, M_col_1)
                Mfy_1 = f(ey)
                f = interpolate.interp1d(M_col_1, fi_1)
                fify_1 = f(Mfy_1)
                My_1 = np.max(M_col_1)
                fiy_1 = My_1 / Mfy_1 * fify_1
                CD_1 = fi_1[-1] / fiy_1

            if np.max(es_col_6) <= ey:
                CD_6 = 0
            else:
                fi_6 = np.absolute(cols_def_6[:, 2 * ind])
                M_col_6 = np.absolute(cols_force_6[:, 2 * ind])
                f = interpolate.interp1d(es_col_6, M_col_6)
                Mfy_6 = f(ey)
                f = interpolate.interp1d(M_col_6, fi_6)
                fify_6 = f(Mfy_6)
                My_6 = np.max(M_col_6)
                fiy_6 = My_6 / Mfy_6 * fify_6
                CD_6 = fi_6[-1] / fiy_6
            CD_Cols[ind - 1, :] = [CD_1, CD_6]
            print('CD_Cols =', CD_Cols)
        CD_Ele = np.concatenate((CD_Cols, CD_Beams), axis=0)

        Desp_x = np.loadtxt('Pushover/HoriNodes.out')
        Desp_y = np.loadtxt('Pushover/VertNodes.out')
        Nodes_desp_x = ListNodes[:, 1] + 3 * Desp_x[-1, 1:]
        Nodes_desp_y = ListNodes[:, 2] + 3 * Desp_y[-1, 1:]

        fpos = 0.1
        fsize = 1
        DataDC = []
        for Ele in Elements:
            xi = Nodes_desp_x[Ele.Nod_ini]
            yi = Nodes_desp_y[Ele.Nod_ini]
            xe = Nodes_desp_x[Ele.Nod_end]
            ye = Nodes_desp_y[Ele.Nod_end]
            x = np.array([xi, xe])
            y = np.array([yi, ye])
            Delta_x = xe-xi
            Delta_y = ye-yi
            xi_CD = xi + fpos * Delta_x
            yi_CD = yi + fpos * Delta_y
            xe_CD = xe - fpos * Delta_x
            ye_CD = ye - fpos * Delta_y
            CD_i = CD_Ele[Ele.EleTag-1, 0]
            CD_e = CD_Ele[Ele.EleTag-1, 1]
            DataDC.append(DuctilityCurve(xi_CD, xe_CD, yi_CD, ye_CD, fsize*CD_i, fsize*CD_e))
        DC_x, DC_y, DC_size = [], [], []
        for DC in DataDC:
            DC_x.append([DC.xi, DC.xe])
            DC_y.append([DC.yi, DC.ye])
            DC_size.append([DC.CD_i, DC.CD_e])
        DC_x = np.array(DC_x)
        DC_x = DC_x.flatten()
        DC_y = np.array(DC_y)
        DC_y = DC_y.flatten()
        DC_size = np.array(DC_size)
        DC_size = DC_size.flatten()
        print('DC_x= ', DC_x)
        print('DC_y= ', DC_y)
        print('DC_size= ', DC_size)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--filenameBIM')
    parser.add_argument('--filenameEVENT')
    parser.add_argument('--filenameSAM')
    parser.add_argument('--getRV', nargs='?', const=True, default=False)
    args = parser.parse_args()
    
    sys.exit(runBuildingDesign(args.filenameBIM, args.filenameEVENT, args.filenameSAM, args.getRV))
